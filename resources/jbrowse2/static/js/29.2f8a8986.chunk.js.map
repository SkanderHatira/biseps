{"version":3,"sources":["../../../node_modules/@gmod/binary-parser/vm-browser.js","../../../node_modules/@gmod/binary-parser/dist/context.js","../../../node_modules/@gmod/twobit/dist/index.js","../../../node_modules/@gmod/twobit/dist/twoBitFile.js","../../../node_modules/@babel/runtime-corejs2/core-js/object/values.js","../../../node_modules/@babel/runtime-corejs2/node_modules/core-js/library/fn/object/values.js","../../../node_modules/@babel/runtime-corejs2/node_modules/core-js/library/modules/es7.object.values.js","../../../node_modules/@babel/runtime-corejs2/node_modules/core-js/library/modules/_object-to-array.js","../../../node_modules/@babel/runtime-corejs2/core-js/number/max-safe-integer.js","../../../node_modules/@babel/runtime-corejs2/node_modules/core-js/library/fn/number/max-safe-integer.js","../../../node_modules/@babel/runtime-corejs2/node_modules/core-js/library/modules/es6.number.max-safe-integer.js","../../../node_modules/@gmod/binary-parser/dist/binary_parser.js"],"names":["module","exports","runInThisContext","code","Function","call","globalThis","_typeof","obj","Symbol","iterator","constructor","prototype","Context","this","scopes","isAsync","bitFields","tmpVariableCount","references","generateVariable","name","arr","Array","push","apply","length","test","pop","replace","join","generateOption","val","toString","concat","generateError","args","slice","arguments","err","interpolate","pushCode","generateTmpVariable","pushPath","popPath","pushScope","popScope","addReference","alias","resolved","requested","markResolved","markRequested","aliasList","forEach","bind","getUnresolvedReferences","Object","keys","filter","s","re","matches","match","params","index","parseInt","substr","TwoBitFile","require","_interopRequireDefault","_promise","_values","_keys","_maxSafeInteger","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_toConsumableArray2","Long","Parser","fs","undefined","TWOBIT_MAGIC","tinyMemoize","_class","methodName","method","memoAttrName","twoBit","byteTo4Bases","default","map","x","i","maskedByteTo4Bases","bases","toLowerCase","LocalFile","path","fdPromise","open","key","value","_read","mark","_callee","buf","offset","position","fd","wrap","_context","prev","next","sent","abrupt","read","stop","_x","_x2","_x3","_x4","_ref","filehandle","seqChunkSize","isBigEndian","_getParser2","_callee2","parser","_context2","_getParsers","t0","Error","_x5","_detectEndianness2","_callee3","_ref2","buffer","_context3","Buffer","allocUnsafe","readInt32LE","version","readInt32BE","_getParsers2","_callee4","endianess","lebe","indexEntryParser","header","_context4","_detectEndianness","uint8","string","uint32","int32","assert","m","v","array","type","record1","record2","record3","_getHeader","_callee5","_ref3","headerParser","_context5","_getParser","parse","result","_getIndex","_callee6","maxIndexLength","_ref4","indexParser","indexData","_this","_context6","getHeader","sequenceCount","_ref5","offsetBytes","long","fromBytes","greaterThan","toNumber","_ref6","_getSequenceNames","_callee7","_context7","getIndex","_getSequenceSizes","_callee8","seqNames","sizePromises","sizes","returnObject","_this2","_context8","_getSequenceSize","all","_getSequenceSize2","_callee9","seqName","_context9","_x6","_getSequenceSize3","_callee10","rec1","_context10","_parseItem","dnaSize","_x7","_getSequenceRecord2","_callee11","rec2DataLength","rec2","rec3DataLength","rec3","rec","_context11","nBlockCount","maskBlockCount","nBlocks","starts","nBlockStarts","nBlockSizes","maskBlocks","maskBlockStarts","maskBlockSizes","dnaPosition","_x8","_parseItem2","_callee12","parserName","_ref7","_context12","_x9","_x10","_x11","_getSequence","_callee13","regionStart","regionEnd","record","baseBytes","baseBytesOffset","_ref8","sequenceBases","genomicPosition","baseIsMasked","currentNBlock","bytePosition","subPosition","byte","_args13","_context13","_getSequenceRecord","TypeError","_getOverlappingBlocks","Math","ceil","floor","end","shift","start","_x12","blockStarts","blockSizes","startIndex","endIndex","blockStart","blocks","blockNum","size","values","$export","$values","S","it","DESCRIPTORS","getKeys","toIObject","isEnum","f","isEntries","O","MAX_SAFE_INTEGER","vm","window","self","PRIMITIVE_TYPES","UInt8","UInt16LE","UInt16BE","UInt32LE","UInt32BE","Int8","Int16LE","Int16BE","Int32LE","Int32BE","FloatLE","FloatBE","DoubleLE","DoubleBE","UInt64","Int64","aliasRegistry","FUNCTION_PREFIX","BIT_RANGE","NAME_MAP","String","Skip","Choice","Nest","Bit","Itf8","Ltf8","varName","options","head","compiled","endian","constructorFn","setNextParser","typeWithoutEndian","namely","skip","zeroTerminated","greedy","stripNull","encoding","readUntil","lengthInBytes","indexOf","choice","tag","choices","nest","create","getCode","ctx","addAliasedCode","addRawCode","generate","resolveReferences","compile","src","sizeOf","NaN","elementSize","generateAssert","formatter","generateFormatter","generateNext","generateBit","JSON","stringify","sum","p","val1","val2","bitOffset","generateSkip","generateString","generateBuffer","clone","generateArray","counter","lhs","item","isHash","tempVar","generateChoiceCase","generateChoice","t","Number","isNaN","defaultChoice","generateNest","nestVar","isInteger","itf8","generateItf8","countFlags","ltf8","generateLtf8"],"mappings":"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","file":"static/js/29.2f8a8986.chunk.js","sourcesContent":["// https://github.com/ionic-team/rollup-plugin-node-polyfills/blob/9b5fe1a9cafffd4871e6d65613ed224f807ea251/polyfills/vm.js#L129-L132\nfunction runInThisContext(code) {\n  const fn = new Function('code', 'return eval(code);');\n  return fn.call(globalThis, code);\n}\n\nmodule.exports.runInThisContext = runInThisContext;\n","\"use strict\";function _typeof(obj) {if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} //= =======================================================================================\n// class Context\n//= =======================================================================================\n\n//----------------------------------------------------------------------------------------\n// constructor\n//----------------------------------------------------------------------------------------\n\nvar Context = function Context() {\n  this.code = \"\";\n  this.scopes = [[\"vars\"]];\n  this.isAsync = false;\n  this.bitFields = [];\n  this.tmpVariableCount = 0;\n  this.references = {};\n};\n\n//----------------------------------------------------------------------------------------\n// public methods\n//----------------------------------------------------------------------------------------\n\nContext.prototype.generateVariable = function (name) {\n  var arr = [];\n\n  Array.prototype.push.apply(arr, this.scopes[this.scopes.length - 1]);\n\n  // $parent. prefixes allow sub-parsers to access values of their parent parsers\n  while (/^\\$parent\\./.test(name)) {\n    arr.pop();\n    name = name.replace(/^\\$parent\\./, \"\");\n  }\n\n  if (name) {\n    arr.push(name);\n  }\n\n  return arr.join(\".\");\n};\n\nContext.prototype.generateOption = function (val) {\n  switch (_typeof(val)) {\n    case \"number\":\n      return val.toString();\n    case \"string\":\n      return this.generateVariable(val);\n    case \"function\":\n      return \"(\".concat(val, \").call(\").concat(this.generateVariable(), \", vars)\");\n    default:\n      return undefined;}\n\n};\n\nContext.prototype.generateError = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var err = Context.interpolate.apply(this, args);\n\n  if (this.isAsync) {\n    this.pushCode(\"return process.nextTick(function() { callback(new Error(\".concat(\n    err, \"), vars); });\"));\n\n  } else {\n    this.pushCode(\"throw new Error(\".concat(err, \");\"));\n  }\n};\n\nContext.prototype.generateTmpVariable = function () {\n  return \"$tmp\".concat(this.tmpVariableCount++);\n};\n\nContext.prototype.pushCode = function () {\n  var args = Array.prototype.slice.call(arguments);\n\n  this.code += \"\".concat(Context.interpolate.apply(this, args), \"\\n\");\n};\n\nContext.prototype.pushPath = function (name) {\n  if (name) {\n    this.scopes[this.scopes.length - 1].push(name);\n  }\n};\n\nContext.prototype.popPath = function (name) {\n  if (name) {\n    this.scopes[this.scopes.length - 1].pop();\n  }\n};\n\nContext.prototype.pushScope = function (name) {\n  this.scopes.push([name]);\n};\n\nContext.prototype.popScope = function () {\n  this.scopes.pop();\n};\n\nContext.prototype.addReference = function (alias) {\n  if (this.references[alias]) return;\n  this.references[alias] = { resolved: false, requested: false };\n};\n\nContext.prototype.markResolved = function (alias) {\n  this.references[alias].resolved = true;\n};\n\nContext.prototype.markRequested = function (aliasList) {\n  aliasList.forEach(\n  function (alias) {\n    this.references[alias].requested = true;\n  }.bind(this));\n\n};\n\nContext.prototype.getUnresolvedReferences = function () {\n  var references = this.references;\n  return Object.keys(this.references).filter(function (alias) {\n    return !references[alias].resolved && !references[alias].requested;\n  });\n};\n\n//----------------------------------------------------------------------------------------\n// private methods\n//----------------------------------------------------------------------------------------\n\nContext.interpolate = function (s) {\n  var re = /{\\d+}/g;\n  var matches = s.match(re);\n  var params = Array.prototype.slice.call(arguments, 1);\n\n  if (matches) {\n    matches.forEach(function (match) {\n      var index = parseInt(match.substr(1, match.length - 2), 10);\n      s = s.replace(match, params[index].toString());\n    });\n  }\n\n  return s;\n};\n\nexports.Context = Context;","\"use strict\";\n\nvar TwoBitFile = require('./twoBitFile');\n\nmodule.exports = {\n  TwoBitFile: TwoBitFile\n};","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _values = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/values\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _maxSafeInteger = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/number/max-safe-integer\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar Long = require('long');\n\nvar _require = require('@gmod/binary-parser'),\n    Parser = _require.Parser;\n\nvar fs = // eslint-disable-next-line camelcase\ntypeof __webpack_require__ !== 'function' ? require('fs-extra') : undefined;\nvar TWOBIT_MAGIC = 0x1a412743;\n\nfunction tinyMemoize(_class, methodName) {\n  var method = _class.prototype[methodName];\n  var memoAttrName = \"_memo_\".concat(methodName);\n\n  _class.prototype[methodName] = function _tinyMemoized() {\n    if (!(memoAttrName in this)) this[memoAttrName] = method.call(this);\n    return this[memoAttrName];\n  };\n}\n\nvar twoBit = ['T', 'C', 'A', 'G']; // byteTo4Bases is an array of byteValue -> 'ACTG'\n// the weird `...keys()` incantation generates an array of numbers 0 to 255\n\nvar byteTo4Bases = (0, _toConsumableArray2.default)(Array(256).keys()).map(function (x, i) {\n  return twoBit[i >> 6 & 3] + twoBit[i >> 4 & 3] + twoBit[i >> 2 & 3] + twoBit[i & 3];\n});\nvar maskedByteTo4Bases = byteTo4Bases.map(function (bases) {\n  return bases.toLowerCase();\n}); // LocalFile is pretty much just an implementation of the node 10+ fs.promises filehandle,\n// can switch to that when the API is stable\n\nvar LocalFile =\n/*#__PURE__*/\nfunction () {\n  function LocalFile(path) {\n    (0, _classCallCheck2.default)(this, LocalFile);\n    this.fdPromise = fs.open(path, 'r');\n  }\n\n  (0, _createClass2.default)(LocalFile, [{\n    key: \"read\",\n    value: function () {\n      var _read = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(buf, offset, length, position) {\n        var fd;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.fdPromise;\n\n              case 2:\n                fd = _context.sent;\n                return _context.abrupt(\"return\", fs.read(fd, buf, offset, length, position));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read(_x, _x2, _x3, _x4) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }]);\n  return LocalFile;\n}();\n\nvar TwoBitFile =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {object} args\n   * @param {string} [args.path] filesystem path for the .2bit file to open\n   * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n   *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n   */\n  function TwoBitFile(_ref) {\n    var filehandle = _ref.filehandle,\n        path = _ref.path,\n        seqChunkSize = _ref.seqChunkSize;\n    (0, _classCallCheck2.default)(this, TwoBitFile);\n    if (filehandle) this.filehandle = filehandle;else if (path) this.filehandle = new LocalFile(path);\n    this.isBigEndian = undefined;\n    this.seqChunkSize = seqChunkSize || 32000;\n  }\n\n  (0, _createClass2.default)(TwoBitFile, [{\n    key: \"_getParser\",\n    value: function () {\n      var _getParser2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2(name) {\n        var parser;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._getParsers();\n\n              case 2:\n                _context2.t0 = name;\n                parser = _context2.sent[_context2.t0];\n\n                if (parser) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new Error(\"parser \".concat(name, \" not found\"));\n\n              case 6:\n                return _context2.abrupt(\"return\", parser);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getParser(_x5) {\n        return _getParser2.apply(this, arguments);\n      }\n\n      return _getParser;\n    }()\n  }, {\n    key: \"_detectEndianness\",\n    value: function () {\n      var _detectEndianness2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee3() {\n        var _ref2, buffer;\n\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0);\n\n              case 2:\n                _ref2 = _context3.sent;\n                buffer = _ref2.buffer;\n\n                if (!(buffer.readInt32LE(0) === TWOBIT_MAGIC)) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                this.isBigEndian = false;\n                this.version = buffer.readInt32LE(4);\n                _context3.next = 15;\n                break;\n\n              case 9:\n                if (!(buffer.readInt32BE(0) === TWOBIT_MAGIC)) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                this.isBigEndian = true;\n                this.version = buffer.readInt32BE(4);\n                _context3.next = 15;\n                break;\n\n              case 14:\n                throw new Error('not a 2bit file');\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _detectEndianness() {\n        return _detectEndianness2.apply(this, arguments);\n      }\n\n      return _detectEndianness;\n    }() // memoize\n\n    /**\n     * @private\n     * detects the file's endianness and instantiates our binary parsers accordingly\n     */\n\n  }, {\n    key: \"_getParsers\",\n    value: function () {\n      var _getParsers2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee4() {\n        var endianess, lebe, indexEntryParser, header;\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._detectEndianness();\n\n              case 2:\n                endianess = this.isBigEndian ? 'big' : 'little';\n                lebe = this.isBigEndian ? 'be' : 'le';\n                indexEntryParser = new Parser().endianess(endianess).uint8('nameLength').string('name', {\n                  length: 'nameLength'\n                });\n\n                if (this.version === 1) {\n                  indexEntryParser = indexEntryParser.buffer('offsetBytes', {\n                    length: 8\n                  });\n                } else {\n                  indexEntryParser = indexEntryParser.uint32('offset');\n                }\n                /* istanbul ignore next */\n\n\n                header = new Parser().endianess(endianess).int32('magic', {\n                  assert: function assert(m) {\n                    return m === 0x1a412743;\n                  }\n                }).int32('version', {\n                  /* istanbul ignore next */\n                  assert: function assert(v) {\n                    return v === 0 || v === 1;\n                  }\n                }).uint32('sequenceCount', {\n                  /* istanbul ignore next */\n                  assert: function assert(v) {\n                    return v >= 0;\n                  }\n                }).uint32('reserved');\n                return _context4.abrupt(\"return\", {\n                  header: header,\n                  index: new Parser().endianess(endianess).uint32('sequenceCount').uint32('reserved').array('index', {\n                    length: 'sequenceCount',\n                    type: indexEntryParser\n                  }),\n                  record1: new Parser().endianess(endianess).uint32('dnaSize').uint32('nBlockCount'),\n                  record2: new Parser().endianess(endianess).uint32('nBlockCount').array('nBlockStarts', {\n                    length: 'nBlockCount',\n                    type: \"uint32\".concat(lebe)\n                  }).array('nBlockSizes', {\n                    length: 'nBlockCount',\n                    type: \"uint32\".concat(lebe)\n                  }).uint32('maskBlockCount'),\n                  record3: new Parser().endianess(endianess).uint32('maskBlockCount').array('maskBlockStarts', {\n                    length: 'maskBlockCount',\n                    type: \"uint32\".concat(lebe)\n                  }).array('maskBlockSizes', {\n                    length: 'maskBlockCount',\n                    type: \"uint32\".concat(lebe)\n                  }).int32('reserved') // .buffer('packedDna', { length: 'dnaSize' }),\n\n                });\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _getParsers() {\n        return _getParsers2.apply(this, arguments);\n      }\n\n      return _getParsers;\n    }() // memoize\n\n    /**\n     * @returns {Promise} for object with the file's header information, like\n     *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`\n     */\n\n  }, {\n    key: \"getHeader\",\n    value: function () {\n      var _getHeader = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee5() {\n        var _ref3, buffer, headerParser;\n\n        return _regenerator.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._detectEndianness();\n\n              case 2:\n                _context5.next = 4;\n                return this.filehandle.read(Buffer.allocUnsafe(16), 0, 16, 0);\n\n              case 4:\n                _ref3 = _context5.sent;\n                buffer = _ref3.buffer;\n                _context5.next = 8;\n                return this._getParser('header');\n\n              case 8:\n                headerParser = _context5.sent;\n                return _context5.abrupt(\"return\", headerParser.parse(buffer).result);\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getHeader() {\n        return _getHeader.apply(this, arguments);\n      }\n\n      return getHeader;\n    }() // memoize\n\n    /**\n     * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`\n     */\n\n  }, {\n    key: \"getIndex\",\n    value: function () {\n      var _getIndex = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee6() {\n        var _this = this;\n\n        var header, maxIndexLength, _ref4, buffer, indexParser, indexData, index;\n\n        return _regenerator.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.getHeader();\n\n              case 2:\n                header = _context6.sent;\n                maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));\n                _context6.next = 6;\n                return this.filehandle.read(Buffer.allocUnsafe(maxIndexLength), 0, maxIndexLength, 8);\n\n              case 6:\n                _ref4 = _context6.sent;\n                buffer = _ref4.buffer;\n                _context6.next = 10;\n                return this._getParser('index');\n\n              case 10:\n                indexParser = _context6.sent;\n                indexData = indexParser.parse(buffer).result.index;\n                index = {};\n\n                if (this.version === 1) {\n                  indexData.forEach(function (_ref5) {\n                    var name = _ref5.name,\n                        offsetBytes = _ref5.offsetBytes;\n                    var long = Long.fromBytes(offsetBytes, true, !_this.isBigEndian);\n                    if (long.greaterThan(_maxSafeInteger.default)) throw new Error('integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.');\n                    index[name] = long.toNumber();\n                  });\n                } else {\n                  indexData.forEach(function (_ref6) {\n                    var name = _ref6.name,\n                        offset = _ref6.offset;\n                    index[name] = offset;\n                  });\n                }\n\n                return _context6.abrupt(\"return\", index);\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getIndex() {\n        return _getIndex.apply(this, arguments);\n      }\n\n      return getIndex;\n    }()\n    /**\n     * @returns {Promise} for an array of string sequence names that are found in the file\n     */\n\n  }, {\n    key: \"getSequenceNames\",\n    value: function () {\n      var _getSequenceNames = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee7() {\n        var index;\n        return _regenerator.default.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.getIndex();\n\n              case 2:\n                index = _context7.sent;\n                return _context7.abrupt(\"return\", (0, _keys.default)(index));\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getSequenceNames() {\n        return _getSequenceNames.apply(this, arguments);\n      }\n\n      return getSequenceNames;\n    }()\n    /**\n     * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`\n     */\n\n  }, {\n    key: \"getSequenceSizes\",\n    value: function () {\n      var _getSequenceSizes = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee8() {\n        var _this2 = this;\n\n        var index, seqNames, sizePromises, sizes, returnObject, i;\n        return _regenerator.default.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.getIndex();\n\n              case 2:\n                index = _context8.sent;\n                seqNames = (0, _keys.default)(index);\n                sizePromises = (0, _values.default)(index).map(function (offset) {\n                  return _this2._getSequenceSize(offset);\n                });\n                _context8.next = 7;\n                return _promise.default.all(sizePromises);\n\n              case 7:\n                sizes = _context8.sent;\n                returnObject = {};\n\n                for (i = 0; i < seqNames.length; i += 1) {\n                  returnObject[seqNames[i]] = sizes[i];\n                }\n\n                return _context8.abrupt(\"return\", returnObject);\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getSequenceSizes() {\n        return _getSequenceSizes.apply(this, arguments);\n      }\n\n      return getSequenceSizes;\n    }()\n    /**\n     * @param {string} seqName name of the sequence\n     * @returns {Promise} for the sequence's length, or undefined if it is not in the file\n     */\n\n  }, {\n    key: \"getSequenceSize\",\n    value: function () {\n      var _getSequenceSize2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee9(seqName) {\n        var index, offset;\n        return _regenerator.default.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.getIndex();\n\n              case 2:\n                index = _context9.sent;\n                offset = index[seqName];\n\n                if (offset) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", undefined);\n\n              case 6:\n                return _context9.abrupt(\"return\", this._getSequenceSize(offset));\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getSequenceSize(_x6) {\n        return _getSequenceSize2.apply(this, arguments);\n      }\n\n      return getSequenceSize;\n    }()\n  }, {\n    key: \"_getSequenceSize\",\n    value: function () {\n      var _getSequenceSize3 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee10(offset) {\n        var rec1;\n        return _regenerator.default.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(offset === undefined || offset < 0)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('invalid offset');\n\n              case 2:\n                _context10.next = 4;\n                return this._parseItem(offset, 8, 'record1');\n\n              case 4:\n                rec1 = _context10.sent;\n                return _context10.abrupt(\"return\", rec1.dnaSize);\n\n              case 6:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _getSequenceSize(_x7) {\n        return _getSequenceSize3.apply(this, arguments);\n      }\n\n      return _getSequenceSize;\n    }()\n  }, {\n    key: \"_getSequenceRecord\",\n    value: function () {\n      var _getSequenceRecord2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee11(offset) {\n        var rec1, rec2DataLength, rec2, rec3DataLength, rec3, rec;\n        return _regenerator.default.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(offset === undefined || offset < 0)) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new Error('invalid offset');\n\n              case 2:\n                _context11.next = 4;\n                return this._parseItem(offset, 8, 'record1');\n\n              case 4:\n                rec1 = _context11.sent;\n                rec2DataLength = rec1.nBlockCount * 8 + 8;\n                _context11.next = 8;\n                return this._parseItem(offset + 4, rec2DataLength, 'record2');\n\n              case 8:\n                rec2 = _context11.sent;\n                rec3DataLength = rec2.maskBlockCount * 8 + 8;\n                _context11.next = 12;\n                return this._parseItem(offset + 4 + rec2DataLength - 4, rec3DataLength, 'record3');\n\n              case 12:\n                rec3 = _context11.sent;\n                rec = {\n                  dnaSize: rec1.dnaSize,\n                  nBlocks: {\n                    starts: rec2.nBlockStarts,\n                    sizes: rec2.nBlockSizes\n                  },\n                  maskBlocks: {\n                    starts: rec3.maskBlockStarts,\n                    sizes: rec3.maskBlockSizes\n                  },\n                  dnaPosition: offset + 4 + rec2DataLength - 4 + rec3DataLength\n                };\n                return _context11.abrupt(\"return\", rec);\n\n              case 15:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _getSequenceRecord(_x8) {\n        return _getSequenceRecord2.apply(this, arguments);\n      }\n\n      return _getSequenceRecord;\n    }()\n  }, {\n    key: \"_parseItem\",\n    value: function () {\n      var _parseItem2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee12(offset, length, parserName) {\n        var _ref7, buffer, parser;\n\n        return _regenerator.default.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.filehandle.read(Buffer.allocUnsafe(length), 0, length, offset);\n\n              case 2:\n                _ref7 = _context12.sent;\n                buffer = _ref7.buffer;\n                _context12.next = 6;\n                return this._getParser(parserName);\n\n              case 6:\n                parser = _context12.sent;\n                return _context12.abrupt(\"return\", parser.parse(buffer).result);\n\n              case 8:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _parseItem(_x9, _x10, _x11) {\n        return _parseItem2.apply(this, arguments);\n      }\n\n      return _parseItem;\n    }()\n    /**\n     * @param {string} seqName name of the sequence you want\n     * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.\n     * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence\n     * @returns {Promise} for a string of sequence bases\n     */\n\n  }, {\n    key: \"getSequence\",\n    value: function () {\n      var _getSequence = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee13(seqName) {\n        var regionStart,\n            regionEnd,\n            index,\n            offset,\n            record,\n            nBlocks,\n            maskBlocks,\n            baseBytes,\n            baseBytesOffset,\n            _ref8,\n            buffer,\n            sequenceBases,\n            genomicPosition,\n            baseIsMasked,\n            currentNBlock,\n            bytePosition,\n            subPosition,\n            byte,\n            _args13 = arguments;\n\n        return _regenerator.default.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                regionStart = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : 0;\n                regionEnd = _args13.length > 2 ? _args13[2] : undefined;\n                _context13.next = 4;\n                return this.getIndex();\n\n              case 4:\n                index = _context13.sent;\n                offset = index[seqName];\n\n                if (offset) {\n                  _context13.next = 8;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", undefined);\n\n              case 8:\n                _context13.next = 10;\n                return this._getSequenceRecord(offset);\n\n              case 10:\n                record = _context13.sent;\n\n                if (!(regionStart < 0)) {\n                  _context13.next = 13;\n                  break;\n                }\n\n                throw new TypeError('regionStart cannot be less than 0');\n\n              case 13:\n                // end defaults to the end of the sequence\n                if (regionEnd === undefined || regionEnd > record.dnaSize) {\n                  regionEnd = record.dnaSize;\n                }\n\n                nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);\n                maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);\n                baseBytes = Buffer.allocUnsafe(Math.ceil((regionEnd - regionStart) / 4) + 1);\n                baseBytesOffset = Math.floor(regionStart / 4);\n                _context13.next = 20;\n                return this.filehandle.read(baseBytes, 0, baseBytes.length, record.dnaPosition + baseBytesOffset);\n\n              case 20:\n                _ref8 = _context13.sent;\n                buffer = _ref8.buffer;\n                sequenceBases = '';\n\n                for (genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {\n                  // check whether we are currently masked\n                  while (maskBlocks.length && maskBlocks[0].end <= genomicPosition) {\n                    maskBlocks.shift();\n                  }\n\n                  baseIsMasked = maskBlocks[0] && maskBlocks[0].start <= genomicPosition && maskBlocks[0].end > genomicPosition; // process the N block if we have one\n\n                  if (nBlocks[0] && genomicPosition >= nBlocks[0].start && genomicPosition < nBlocks[0].end) {\n                    currentNBlock = nBlocks.shift();\n\n                    for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {\n                      sequenceBases += baseIsMasked ? 'n' : 'N';\n                    }\n\n                    genomicPosition -= 1;\n                  } else {\n                    bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;\n                    subPosition = genomicPosition % 4;\n                    byte = buffer[bytePosition];\n                    sequenceBases += baseIsMasked ? maskedByteTo4Bases[byte][subPosition] : byteTo4Bases[byte][subPosition];\n                  }\n                }\n\n                return _context13.abrupt(\"return\", sequenceBases);\n\n              case 25:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getSequence(_x12) {\n        return _getSequence.apply(this, arguments);\n      }\n\n      return getSequence;\n    }()\n  }, {\n    key: \"_getOverlappingBlocks\",\n    value: function _getOverlappingBlocks(regionStart, regionEnd, blockStarts, blockSizes) {\n      // find the start and end indexes of the blocks that match\n      var startIndex;\n      var endIndex;\n\n      for (var i = 0; i < blockStarts.length; i += 1) {\n        var blockStart = blockStarts[i];\n        var blockSize = blockSizes[i];\n\n        if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n          // block does not overlap the region\n          if (startIndex !== undefined) {\n            endIndex = i;\n            break;\n          }\n        } else if (startIndex === undefined) startIndex = i; // block does overlap the region, record this if it is the first\n\n      }\n\n      if (startIndex === undefined) return []; // now format some block objects to return\n\n      if (endIndex === undefined) endIndex = blockStarts.length;\n      var blocks = new Array(endIndex - startIndex);\n\n      for (var blockNum = startIndex; blockNum < endIndex; blockNum += 1) {\n        blocks[blockNum - startIndex] = {\n          start: blockStarts[blockNum],\n          end: blockStarts[blockNum] + blockSizes[blockNum],\n          size: blockSizes[blockNum]\n        };\n      }\n\n      return blocks;\n    }\n  }]);\n  return TwoBitFile;\n}();\n\ntinyMemoize(TwoBitFile, '_getParsers');\ntinyMemoize(TwoBitFile, 'getIndex');\ntinyMemoize(TwoBitFile, 'getHeader');\nmodule.exports = TwoBitFile;","module.exports = require(\"core-js/library/fn/object/values\");","require('../../modules/es7.object.values');\nmodule.exports = require('../../modules/_core').Object.values;\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n","var DESCRIPTORS = require('./_descriptors');\nvar getKeys = require('./_object-keys');\nvar toIObject = require('./_to-iobject');\nvar isEnum = require('./_object-pie').f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || isEnum.call(O, key)) {\n        result.push(isEntries ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n","module.exports = require(\"core-js/library/fn/number/max-safe-integer\");","require('../../modules/es6.number.max-safe-integer');\nmodule.exports = 0x1fffffffffffff;\n","// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });\n","\"use strict\";function _typeof(obj) {if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} //= =======================================================================================\n// Globals\n//= =======================================================================================\nvar _require = require(\"buffer\"),Buffer = _require.Buffer;\nvar vm = require(\"vm\");\n\nvar Context = require(\"./context\").Context;\nvar Long = require(\"long\");\n\nif (typeof window !== \"undefined\") window.Buffer = Buffer;\nif (typeof self !== \"undefined\") self.Buffer = Buffer; // this is for webworker, and also is not an elseif to avoid window polyfills in webworker\n\nvar PRIMITIVE_TYPES = {\n  UInt8: 1,\n  UInt16LE: 2,\n  UInt16BE: 2,\n  UInt32LE: 4,\n  UInt32BE: 4,\n  Int8: 1,\n  Int16LE: 2,\n  Int16BE: 2,\n  Int32LE: 4,\n  Int32BE: 4,\n  FloatLE: 4,\n  FloatBE: 4,\n  DoubleLE: 8,\n  DoubleBE: 8,\n  UInt64: 8,\n  Int64: 8 };\n\n\nvar SPECIAL_TYPES = {\n  String: null,\n  Buffer: null,\n  Array: null,\n  Skip: null,\n  Choice: null,\n  Nest: null,\n  Bit: null,\n  Itf8: null,\n  Ltf8: null };\n\n\nvar aliasRegistry = {};\nvar FUNCTION_PREFIX = \"___parser_\";\n\nvar BIT_RANGE = [];\n(function () {\n  var i;\n  for (i = 1; i <= 32; i++) {\n    BIT_RANGE.push(i);\n  }\n})();\n\n// Converts Parser's method names to internal type names\nvar NAME_MAP = {};\nObject.keys(PRIMITIVE_TYPES).\nconcat(Object.keys(SPECIAL_TYPES)).\nforEach(function (type) {\n  NAME_MAP[type.toLowerCase()] = type;\n});\n\n//= =======================================================================================\n// class Parser\n//= =======================================================================================\n\n//----------------------------------------------------------------------------------------\n// constructor\n//----------------------------------------------------------------------------------------\n\nvar Parser = function Parser() {\n  this.varName = \"\";\n  this.type = \"\";\n  this.options = {};\n  this.next = null;\n  this.head = null;\n  this.compiled = null;\n  this.endian = \"le\";\n  this.constructorFn = null;\n  this.alias = null;\n};\n\n//----------------------------------------------------------------------------------------\n// public methods\n//----------------------------------------------------------------------------------------\n\nParser.start = function () {\n  return new Parser();\n};\n\nObject.keys(PRIMITIVE_TYPES).forEach(function (type) {\n  Parser.prototype[type.toLowerCase()] = function (varName, options) {\n    return this.setNextParser(type.toLowerCase(), varName, options);\n  };\n\n  var typeWithoutEndian = type.replace(/BE|LE/, \"\").toLowerCase();\n  if (!(typeWithoutEndian in Parser.prototype)) {\n    Parser.prototype[typeWithoutEndian] = function (varName, options) {\n      return this[typeWithoutEndian + this.endian](varName, options);\n    };\n  }\n});\n\nBIT_RANGE.forEach(function (i) {\n  Parser.prototype[\"bit\".concat(i.toString())] = function (varName, options) {\n    if (!options) {\n      options = {};\n    }\n    options.length = i;\n    return this.setNextParser(\"bit\", varName, options);\n  };\n});\n\nParser.prototype.namely = function (alias) {\n  aliasRegistry[alias] = this;\n  this.alias = alias;\n  return this;\n};\n\nParser.prototype.skip = function (length, options) {\n  if (options && options.assert) {\n    throw new Error(\"assert option on skip is not allowed.\");\n  }\n\n  return this.setNextParser(\"skip\", \"\", { length: length });\n};\n\nParser.prototype.string = function (varName, options) {\n  if (!options.zeroTerminated && !options.length && !options.greedy) {\n    throw new Error(\n    \"Neither length, zeroTerminated, nor greedy is defined for string.\");\n\n  }\n  if ((options.zeroTerminated || options.length) && options.greedy) {\n    throw new Error(\n    \"greedy is mutually exclusive with length and zeroTerminated for string.\");\n\n  }\n  if (options.stripNull && !(options.length || options.greedy)) {\n    throw new Error(\n    \"Length or greedy must be defined if stripNull is defined.\");\n\n  }\n  options.encoding = options.encoding || \"utf8\";\n\n  return this.setNextParser(\"string\", varName, options);\n};\n\nParser.prototype.buffer = function (varName, options) {\n  if (!options.length && !options.readUntil) {\n    throw new Error(\"Length nor readUntil is defined in buffer parser\");\n  }\n\n  return this.setNextParser(\"buffer\", varName, options);\n};\n\nParser.prototype.array = function (varName, options) {\n  if (!options.readUntil && !options.length && !options.lengthInBytes) {\n    throw new Error(\"Length option of array is not defined.\");\n  }\n  if (!options.type) {\n    throw new Error(\"Type option of array is not defined.\");\n  }\n  if (\n  typeof options.type === \"string\" &&\n  !aliasRegistry[options.type] &&\n  Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.type]) < 0)\n  {\n    throw new Error(\"Specified primitive type \\\"\".concat(\n    options.type, \"\\\" is not supported.\"));\n\n  }\n\n  return this.setNextParser(\"array\", varName, options);\n};\n\nParser.prototype.choice = function (varName, options) {\n  if (arguments.length === 1 && _typeof(varName) === \"object\") {\n    options = varName;\n    varName = null;\n  }\n\n  if (!options.tag) {\n    throw new Error(\"Tag option of array is not defined.\");\n  }\n  if (!options.choices) {\n    throw new Error(\"Choices option of array is not defined.\");\n  }\n\n  Object.keys(options.choices).forEach(function (key) {\n    // if (isNaN(parseInt(key, 10))) {\n    //   throw new Error(\"Key of choices must be a number.\");\n    // }\n    if (!options.choices[key]) {\n      throw new Error(\"Choice Case \".concat(key, \" of \").concat(varName, \" is not valid.\"));\n    }\n\n    if (\n    typeof options.choices[key] === \"string\" &&\n    !aliasRegistry[options.choices[key]] &&\n    Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.choices[key]]) < 0)\n    {\n      throw new Error(\"Specified primitive type \\\"\".concat(\n      options.choices[key], \"\\\" is not supported.\"));\n\n    }\n  }, this);\n\n  return this.setNextParser(\"choice\", varName, options);\n};\n\nParser.prototype.nest = function (varName, options) {\n  if (arguments.length === 1 && _typeof(varName) === \"object\") {\n    options = varName;\n    varName = null;\n  }\n\n  if (!options.type) {\n    throw new Error(\"Type option of nest is not defined.\");\n  }\n  if (!(options.type instanceof Parser) && !aliasRegistry[options.type]) {\n    throw new Error(\"Type option of nest must be a Parser object.\");\n  }\n  if (!(options.type instanceof Parser) && !varName) {\n    throw new Error(\n    \"options.type must be a object if variable name is omitted.\");\n\n  }\n\n  return this.setNextParser(\"nest\", varName, options);\n};\n\nParser.prototype.endianess = function (endianess) {\n  switch (endianess.toLowerCase()) {\n    case \"little\":\n      this.endian = \"le\";\n      break;\n    case \"big\":\n      this.endian = \"be\";\n      break;\n    default:\n      throw new Error(\"Invalid endianess: \".concat(endianess));}\n\n\n  return this;\n};\n\nParser.prototype.create = function (constructorFn) {\n  if (!(constructorFn instanceof Function)) {\n    throw new Error(\"Constructor must be a Function object.\");\n  }\n\n  this.constructorFn = constructorFn;\n\n  return this;\n};\n\nParser.prototype.getCode = function () {\n  var ctx = new Context();\n\n  ctx.pushCode(\"if (!Buffer.isBuffer(buffer)) {\");\n  ctx.generateError('\"argument buffer is not a Buffer object\"');\n  ctx.pushCode(\"}\");\n\n  if (!this.alias) {\n    this.addRawCode(ctx);\n  } else {\n    this.addAliasedCode(ctx);\n  }\n\n  if (this.alias) {\n    ctx.pushCode(\"return {0}(0)\", FUNCTION_PREFIX + this.alias);\n  } else {\n    ctx.pushCode(\"return { offset: offset, result: vars };\");\n  }\n\n  return ctx.code;\n};\n\nParser.prototype.addRawCode = function (ctx) {\n  ctx.pushCode(\"var offset = 0;\");\n\n  if (this.constructorFn) {\n    ctx.pushCode(\"var vars = new constructorFn();\");\n  } else {\n    ctx.pushCode(\"var vars = {};\");\n  }\n\n  this.generate(ctx);\n\n  this.resolveReferences(ctx);\n\n  ctx.pushCode(\"return { offset: offset, result: vars };\");\n};\n\nParser.prototype.addAliasedCode = function (ctx) {\n  ctx.pushCode(\"function {0}(offset) {\", FUNCTION_PREFIX + this.alias);\n\n  if (this.constructorFn) {\n    ctx.pushCode(\"var vars = new constructorFn();\");\n  } else {\n    ctx.pushCode(\"var vars = {};\");\n  }\n\n  this.generate(ctx);\n\n  ctx.markResolved(this.alias);\n  this.resolveReferences(ctx);\n\n  ctx.pushCode(\"return { offset: offset, result: vars };\");\n  ctx.pushCode(\"}\");\n\n  return ctx;\n};\n\nParser.prototype.resolveReferences = function (ctx) {\n  var references = ctx.getUnresolvedReferences();\n  ctx.markRequested(references);\n  references.forEach(function (alias) {\n    var parser = aliasRegistry[alias];\n    parser.addAliasedCode(ctx);\n  });\n};\n\nParser.prototype.compile = function () {\n  var src = \"(function(buffer, constructorFn, Long) { \".concat(this.getCode(), \" })\");\n  this.compiled = vm.runInThisContext(src);\n};\n\nParser.prototype.sizeOf = function () {\n  var size = NaN;\n\n  if (Object.keys(PRIMITIVE_TYPES).indexOf(this.type) >= 0) {\n    size = PRIMITIVE_TYPES[this.type];\n\n    // if this is a fixed length string\n  } else if (\n  this.type === \"String\" &&\n  typeof this.options.length === \"number\")\n  {\n    size = this.options.length;\n\n    // if this is a fixed length buffer\n  } else if (\n  this.type === \"Buffer\" &&\n  typeof this.options.length === \"number\")\n  {\n    size = this.options.length;\n\n    // if this is a fixed length array\n  } else if (this.type === \"Array\" && typeof this.options.length === \"number\") {\n    var elementSize = NaN;\n    if (typeof this.options.type === \"string\") {\n      elementSize = PRIMITIVE_TYPES[NAME_MAP[this.options.type]];\n    } else if (this.options.type instanceof Parser) {\n      elementSize = this.options.type.sizeOf();\n    }\n    size = this.options.length * elementSize;\n\n    // if this a skip\n  } else if (this.type === \"Skip\") {\n    size = this.options.length;\n\n    // if this is a nested parser\n  } else if (this.type === \"Nest\") {\n    size = this.options.type.sizeOf();\n  } else if (!this.type) {\n    size = 0;\n  }\n\n  if (this.next) {\n    size += this.next.sizeOf();\n  }\n\n  return size;\n};\n\n// Follow the parser chain till the root and start parsing from there\nParser.prototype.parse = function (buffer) {\n  if (!this.compiled) {\n    this.compile();\n  }\n\n  return this.compiled(buffer, this.constructorFn, Long);\n};\n\n//----------------------------------------------------------------------------------------\n// private methods\n//----------------------------------------------------------------------------------------\n\nParser.prototype.setNextParser = function (type, varName, options) {\n  var parser = new Parser();\n\n  parser.type = NAME_MAP[type];\n  parser.varName = varName;\n  parser.options = options || parser.options;\n  parser.endian = this.endian;\n\n  if (this.head) {\n    this.head.next = parser;\n  } else {\n    this.next = parser;\n  }\n  this.head = parser;\n\n  return this;\n};\n\n// Call code generator for this parser\nParser.prototype.generate = function (ctx) {\n  if (this.type) {\n    this[\"generate\".concat(this.type)](ctx);\n    this.generateAssert(ctx);\n  }\n\n  var varName = ctx.generateVariable(this.varName);\n  if (this.options.formatter) {\n    this.generateFormatter(ctx, varName, this.options.formatter);\n  }\n\n  return this.generateNext(ctx);\n};\n\nParser.prototype.generateAssert = function (ctx) {\n  if (!this.options.assert) {\n    return;\n  }\n\n  var varName = ctx.generateVariable(this.varName);\n\n  switch (_typeof(this.options.assert)) {\n    case \"function\":\n      ctx.pushCode(\n      \"if (!({0}).call(vars, {1})) {\",\n      this.options.assert,\n      varName);\n\n      break;\n    case \"number\":\n      ctx.pushCode(\"if ({0} !== {1}) {\", this.options.assert, varName);\n      break;\n    case \"string\":\n      ctx.pushCode('if (\"{0}\" !== {1}) {', this.options.assert, varName);\n      break;\n    default:\n      throw new Error(\n      \"Assert option supports only strings, numbers and assert functions.\");}\n\n\n  ctx.generateError('\"Assert error: {0} is \" + {0}', varName);\n  ctx.pushCode(\"}\");\n};\n\n// Recursively call code generators and append results\nParser.prototype.generateNext = function (ctx) {\n  if (this.next) {\n    ctx = this.next.generate(ctx);\n  }\n\n  return ctx;\n};\n\nObject.keys(PRIMITIVE_TYPES).forEach(function (type) {\n  Parser.prototype[\"generate\".concat(type)] = function (ctx) {\n    if (type === \"UInt64\") {\n      ctx.pushCode(\n      \"{0} = Long.fromBytes(buffer.slice(offset,offset+8), true, this.endian === 'le').toNumber();\",\n      ctx.generateVariable(this.varName),\n      type);\n\n    } else if (type === \"Int64\") {\n      ctx.pushCode(\n      \"{0} = Long.fromBytes(buffer.slice(offset,offset+8), false, this.endian === 'le').toNumber();\",\n      ctx.generateVariable(this.varName),\n      type);\n\n    } else {\n      ctx.pushCode(\n      \"{0} = buffer.read{1}(offset);\",\n      ctx.generateVariable(this.varName),\n      type);\n\n    }\n    ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[type]);\n  };\n});\n\nParser.prototype.generateBit = function (ctx) {\n  // TODO find better method to handle nested bit fields\n  var parser = JSON.parse(JSON.stringify(this));\n  parser.varName = ctx.generateVariable(parser.varName);\n  ctx.bitFields.push(parser);\n\n  if (\n  !this.next ||\n  this.next && [\"Bit\", \"Nest\"].indexOf(this.next.type) < 0)\n  {\n    var sum = 0;\n    ctx.bitFields.forEach(function (p) {\n      sum += p.options.length;\n    });\n\n    var val = ctx.generateTmpVariable();\n\n    if (sum <= 8) {\n      ctx.pushCode(\"var {0} = buffer.readUInt8(offset);\", val);\n      sum = 8;\n    } else if (sum <= 16) {\n      ctx.pushCode(\"var {0} = buffer.readUInt16BE(offset);\", val);\n      sum = 16;\n    } else if (sum <= 24) {\n      var val1 = ctx.generateTmpVariable();\n      var val2 = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = buffer.readUInt16BE(offset);\", val1);\n      ctx.pushCode(\"var {0} = buffer.readUInt8(offset + 2);\", val2);\n      ctx.pushCode(\"var {2} = ({0} << 8) | {1};\", val1, val2, val);\n      sum = 24;\n    } else if (sum <= 32) {\n      ctx.pushCode(\"var {0} = buffer.readUInt32BE(offset);\", val);\n      sum = 32;\n    } else {\n      throw new Error(\n      \"Currently, bit field sequence longer than 4-bytes is not supported.\");\n\n    }\n    ctx.pushCode(\"offset += {0};\", sum / 8);\n\n    var bitOffset = 0;\n    var isBigEndian = this.endian === \"be\";\n    ctx.bitFields.forEach(function (p) {\n      ctx.pushCode(\n      \"{0} = {1} >> {2} & {3};\",\n      p.varName,\n      val,\n      isBigEndian ? sum - bitOffset - p.options.length : bitOffset,\n      (1 << p.options.length) - 1);\n\n      bitOffset += p.options.length;\n    });\n\n    ctx.bitFields = [];\n  }\n};\n\nParser.prototype.generateSkip = function (ctx) {\n  var length = ctx.generateOption(this.options.length);\n  ctx.pushCode(\"offset += {0};\", length);\n};\n\nParser.prototype.generateString = function (ctx) {\n  var name = ctx.generateVariable(this.varName);\n  var start = ctx.generateTmpVariable();\n\n  if (this.options.length && this.options.zeroTerminated) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\n    \"while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});\",\n    start,\n    this.options.length);\n\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);\",\n    name,\n    this.options.encoding,\n    start,\n    this.options.length);\n\n  } else if (this.options.length) {\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', offset, offset + {2});\",\n    name,\n    this.options.encoding,\n    ctx.generateOption(this.options.length));\n\n    ctx.pushCode(\"offset += {0};\", ctx.generateOption(this.options.length));\n  } else if (this.options.zeroTerminated) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\"while(buffer.readUInt8(offset++) !== 0);\");\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', {2}, offset - 1);\",\n    name,\n    this.options.encoding,\n    start);\n\n  } else if (this.options.greedy) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\"while(buffer.length > offset++);\");\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', {2}, offset);\",\n    name,\n    this.options.encoding,\n    start);\n\n  }\n  if (this.options.stripNull) {\n    ctx.pushCode(\"{0} = {0}.replace(/\\\\x00+$/g, '')\", name);\n  }\n};\n\nParser.prototype.generateBuffer = function (ctx) {\n  if (this.options.readUntil === \"eof\") {\n    ctx.pushCode(\n    \"{0} = buffer.slice(offset);\",\n    ctx.generateVariable(this.varName));\n\n  } else {\n    ctx.pushCode(\n    \"{0} = buffer.slice(offset, offset + {1});\",\n    ctx.generateVariable(this.varName),\n    ctx.generateOption(this.options.length));\n\n    ctx.pushCode(\"offset += {0};\", ctx.generateOption(this.options.length));\n  }\n\n  if (this.options.clone) {\n    ctx.pushCode(\"{0} = Buffer.from({0});\", ctx.generateVariable(this.varName));\n  }\n};\n\nParser.prototype.generateArray = function (ctx) {\n  var length = ctx.generateOption(this.options.length);\n  var lengthInBytes = ctx.generateOption(this.options.lengthInBytes);\n  var type = this.options.type;\n  var counter = ctx.generateTmpVariable();\n  var lhs = ctx.generateVariable(this.varName);\n  var item = ctx.generateTmpVariable();\n  var key = this.options.key;\n  var isHash = typeof key === \"string\";\n\n  if (isHash) {\n    ctx.pushCode(\"{0} = {};\", lhs);\n  } else {\n    ctx.pushCode(\"{0} = [];\", lhs);\n  }\n  if (typeof this.options.readUntil === \"function\") {\n    ctx.pushCode(\"do {\");\n  } else if (this.options.readUntil === \"eof\") {\n    ctx.pushCode(\"for (var {0} = 0; offset < buffer.length; {0}++) {\", counter);\n  } else if (lengthInBytes !== undefined) {\n    ctx.pushCode(\n    \"for (var {0} = offset; offset - {0} < {1}; ) {\",\n    counter,\n    lengthInBytes);\n\n  } else {\n    ctx.pushCode(\"for (var {0} = 0; {0} < {1}; {0}++) {\", counter, length);\n  }\n\n  if (typeof type === \"string\") {\n    if (!aliasRegistry[type]) {\n      ctx.pushCode(\"var {0} = buffer.read{1}(offset);\", item, NAME_MAP[type]);\n      ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[NAME_MAP[type]]);\n    } else {\n      var tempVar = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = {1}(offset);\", tempVar, FUNCTION_PREFIX + type);\n      ctx.pushCode(\"var {0} = {1}.result; offset = {1}.offset;\", item, tempVar);\n      if (type !== this.alias) ctx.addReference(type);\n    }\n  } else if (type instanceof Parser) {\n    ctx.pushCode(\"var {0} = {};\", item);\n\n    ctx.pushScope(item);\n    type.generate(ctx);\n    ctx.popScope();\n  }\n\n  if (isHash) {\n    ctx.pushCode(\"{0}[{2}.{1}] = {2};\", lhs, key, item);\n  } else {\n    ctx.pushCode(\"{0}.push({1});\", lhs, item);\n  }\n\n  ctx.pushCode(\"}\");\n\n  if (typeof this.options.readUntil === \"function\") {\n    ctx.pushCode(\n    \" while (!({0}).call(this, {1}, buffer.slice(offset)));\",\n    this.options.readUntil,\n    item);\n\n  }\n};\n\nParser.prototype.generateChoiceCase = function (ctx, varName, type) {\n  if (typeof type === \"string\") {\n    if (!aliasRegistry[type]) {\n      ctx.pushCode(\n      \"{0} = buffer.read{1}(offset);\",\n      ctx.generateVariable(this.varName),\n      NAME_MAP[type]);\n\n      ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[NAME_MAP[type]]);\n    } else {\n      var tempVar = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = {1}(offset);\", tempVar, FUNCTION_PREFIX + type);\n      ctx.pushCode(\n      \"{0} = {1}.result; offset = {1}.offset;\",\n      ctx.generateVariable(this.varName),\n      tempVar);\n\n      if (type !== this.alias) ctx.addReference(type);\n    }\n  } else if (type instanceof Parser) {\n    ctx.pushPath(varName);\n    type.generate(ctx);\n    ctx.popPath(varName);\n  }\n};\n\nParser.prototype.generateChoice = function (ctx) {\n  var tag = ctx.generateOption(this.options.tag);\n  if (this.varName) {\n    ctx.pushCode(\"{0} = {};\", ctx.generateVariable(this.varName));\n  }\n  ctx.pushCode(\"switch({0}) {\", tag);\n  Object.keys(this.options.choices).forEach(function (t) {\n    var type = this.options.choices[t];\n    if (Number.isNaN(parseInt(t, 10))) {\n      ctx.pushCode(\"case '{0}':\", t);\n    } else {\n      ctx.pushCode(\"case {0}:\", t);\n    }\n    this.generateChoiceCase(ctx, this.varName, type);\n    ctx.pushCode(\"break;\");\n  }, this);\n  ctx.pushCode(\"default:\");\n  if (this.options.defaultChoice) {\n    this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);\n  } else {\n    ctx.generateError('\"Met undefined tag value \" + {0} + \" at choice\"', tag);\n  }\n  ctx.pushCode(\"}\");\n};\n\nParser.prototype.generateNest = function (ctx) {\n  var nestVar = ctx.generateVariable(this.varName);\n\n  if (this.options.type instanceof Parser) {\n    if (this.varName) {\n      ctx.pushCode(\"{0} = {};\", nestVar);\n    }\n    ctx.pushPath(this.varName);\n    this.options.type.generate(ctx);\n    ctx.popPath(this.varName);\n  } else if (aliasRegistry[this.options.type]) {\n    var tempVar = ctx.generateTmpVariable();\n    ctx.pushCode(\n    \"var {0} = {1}(offset);\",\n    tempVar,\n    FUNCTION_PREFIX + this.options.type);\n\n    ctx.pushCode(\"{0} = {1}.result; offset = {1}.offset;\", nestVar, tempVar);\n    if (this.options.type !== this.alias) ctx.addReference(this.options.type);\n  }\n};\n\nParser.prototype.generateFormatter = function (ctx, varName, formatter) {\n  if (typeof formatter === \"function\") {\n    ctx.pushCode(\"{0} = ({1}).call(this, {0});\", varName, formatter);\n  }\n};\n\nParser.prototype.isInteger = function () {\n  return !!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\\d+/);\n};\n\n// /////////////////// CRAM-specific types //////////////////////////\n//\nParser.prototype.itf8 = function (varName, options) {\n  return this.setNextParser(\"itf8\", varName, options);\n};\nParser.prototype.itf8 = function (varName, options) {\n  return this.setNextParser(\"itf8\", varName, options);\n};\n\nParser.prototype.generateItf8 = function (ctx) {\n  var name = ctx.generateVariable(this.varName);\n  var countFlags = ctx.generateTmpVariable();\n  ctx.pushCode(\"\\n    var \".concat(\n  countFlags, \" = buffer[offset];\\n    if (\").concat(\n  countFlags, \" < 0x80) {\\n      \").concat(\n  name, \" = \").concat(countFlags, \";\\n      offset += 1;\\n    } else if (\").concat(\n\n  countFlags, \" < 0xc0) {\\n      \").concat(\n  name, \" = ((\").concat(countFlags, \"<<8) | buffer[offset+1]) & 0x3fff;\\n      offset += 2;\\n    } else if (\").concat(\n\n  countFlags, \" < 0xe0) {\\n      \").concat(\n  name, \" = ((\").concat(countFlags, \"<<16) | (buffer[offset+1]<< 8) |  buffer[offset+2]) & 0x1fffff;\\n      offset += 3;\\n    } else if (\").concat(\n\n  countFlags, \" < 0xf0) {\\n      \").concat(\n  name, \" = ((\").concat(countFlags, \"<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\\n      offset += 4\\n    } else {\\n      \").concat(\n\n\n  name, \" = ((\").concat(countFlags, \" & 0x0f)<<28) | (buffer[offset+1]<<20) | (buffer[offset+2]<<12) | (buffer[offset+3]<<4) | (buffer[offset+4] & 0x0f);\\n      // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);\\n      // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\\n      offset += 5\\n    }\\n  \"));\n\n\n\n\n\n};\n\nParser.prototype.ltf8 = function (varName, options) {\n  return this.setNextParser(\"ltf8\", varName, options);\n};\n\nParser.prototype.generateLtf8 = function (ctx) {\n  var name = ctx.generateVariable(this.varName);\n  var countFlags = ctx.generateTmpVariable();\n  ctx.pushCode(\"\\n  var \".concat(\n  countFlags, \" = buffer[offset];\\n  if (\").concat(\n  countFlags, \" < 0x80) {\\n    \").concat(\n  name, \" = \").concat(countFlags, \";\\n    offset += 1;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xc0) {\\n    \").concat(\n  name, \" = ((buffer[offset]<<8) | buffer[offset+1]) & 0x3fff;\\n    offset += 2;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xe0) {\\n    \").concat(\n  name, \" = ((buffer[offset]<<16) | (buffer[offset+1]<<8) | buffer[offset+2]) & 0x1fffff;\\n    \").concat(\n  name, \" = (((\").concat(countFlags, \" & 63) << 16) | buffer.readUInt16LE(offset + 1));\\n    offset += 3;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xf0) {\\n    \").concat(\n  name, \" = ((buffer[offset]<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\\n    offset += 4;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xf8) {\\n    \").concat(\n  name, \" = (((buffer[offset] & 15) * Math.pow(2,32))) +\\n      (buffer[offset+1]<<24) | (buffer[offset+2]<<16 | buffer[offset+3]<<8 | buffer[offset+4])\\n    // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\\n    offset += 5;\\n  } else if (\").concat(\n\n\n\n  countFlags, \" < 0xfc) {\\n    \").concat(\n  name, \" = ((((buffer[offset] & 7) << 8) | buffer[offset+1] )) * Math.pow(2,32) +\\n      (buffer[offset+2]<<24) | (buffer[offset+3]<<16 | buffer[offset+4]<<8 | buffer[offset+5])\\n    offset += 6;\\n  } else if (\").concat(\n\n\n  countFlags, \" < 0xfe) {\\n    \").concat(\n  name, \" = ((((buffer[offset] & 3) << 16) | buffer[offset+1]<<8 | buffer[offset+2])) * Math.pow(2,32) +\\n      (buffer[offset+3]<<24) | (buffer[offset+4]<<16 | buffer[offset+5]<<8 | buffer[offset+6])\\n    offset += 7;\\n  } else if (\").concat(\n\n\n  countFlags, \" < 0xff) {\\n    \").concat(\n  name, \" = Long.fromBytesBE(buffer.slice(offset+1,offset+8));\\n    if (\").concat(\n  name, \".greaterThan(Number.MAX_SAFE_INTEGER) || \").concat(name, \".lessThan(Number.MIN_SAFE_INTEGER))\\n      throw new Error('integer overflow')\\n    \").concat(\n\n  name, \" = \").concat(name, \".toNumber()\\n    offset += 8;\\n  } else {\\n    \").concat(\n\n\n  name, \" = Long.fromBytesBE(buffer.slice(offset+1,offset+9));\\n    if (\").concat(\n  name, \".greaterThan(Number.MAX_SAFE_INTEGER) || \").concat(name, \".lessThan(Number.MIN_SAFE_INTEGER))\\n      throw new Error('integer overflow')\\n    \").concat(\n\n  name, \" = \").concat(name, \".toNumber()\\n    offset += 9;\\n  }\\n  \"));\n\n\n\n};\n\n//= =======================================================================================\n// Exports\n//= =======================================================================================\n\nexports.Parser = Parser;"],"sourceRoot":""}