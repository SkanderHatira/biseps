{"version":3,"sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts","../../../node_modules/@flatten-js/interval-tree/dist/main.esm.js"],"names":["readVcf","f","lines","split","header","rest","forEach","line","startsWith","push","join","isGzip","buf","VcfAdapter","vcfFeatures","this","setup","a","parser","VCF","getMetadata","openLocation","readConfObject","config","pluginManager","readFile","buffer","unzip","length","Error","str","TextDecoder","decode","intervalTree","map","id","refName","startP","ref","start","end","match","trim","reduce","acc","obj","key","IntervalTree","insert","setupP","catch","e","undefined","Object","keys","region","opts","ObservableCreate","observer","search","next","VcfFeature","variant","parseLine","complete","error","signal","BaseFeatureDataAdapter","capabilities","Interval","low","high","clone","other_interval","not_intersect","Math","min","max","interval1","interval2","merge","val1","val2","Node","value","left","right","parent","color","item","Array","Number","isNaN","other_node","less_than","value_less_than","equal_to","value_equal","intersect","comparable_max","constructor","search_node","comparable_less_than","root","nil_node","count","tree_walk","res","node","output","insert_node","tree_insert","recalc_max","tree_search","delete_node","tree_delete","interval","outputMapperFn","resp_nodes","tree_search_interval","tree_find_any_interval","visitor","callback","tree","node_current","update_max","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","tree_successor","copy_data","delete_fixup","brother_node","not_intersect_left_subtree","not_intersect_right_subtree","found","node_min","node_max","node_successor","local_minimum","x","y","action","height","heightLeft","testBlackHeightProperty"],"mappings":"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","file":"static/js/37.09d31b93.chunk.js","sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VCF from '@gmod/vcf'\nimport VcfFeature from '../VcfTabixAdapter/VcfFeature'\n\nconst readVcf = (f: string) => {\n  const lines = f.split('\\n')\n  const header: string[] = []\n  const rest: string[] = []\n  lines.forEach(line => {\n    if (line.startsWith('#')) {\n      header.push(line)\n    } else if (line) {\n      rest.push(line)\n    }\n  })\n  return { header: header.join('\\n'), lines: rest }\n}\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected vcfFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  // converts lines into an interval tree\n  public async setupP() {\n    const buffer = await openLocation(\n      readConfObject(this.config, 'vcfLocation'),\n      this.pluginManager,\n    ).readFile()\n\n    const buf = isGzip(buffer as Buffer) ? await unzip(buffer) : buffer\n\n    // 512MB  max chrome string length is 512MB\n    if (buf.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n\n    const str = new TextDecoder().decode(buf)\n    const { header, lines } = readVcf(str)\n\n    const intervalTree = lines\n      .map((line, id) => {\n        const [refName, startP, , ref, , , , info] = line.split('\\t')\n        const start = +startP - 1\n        const end = +(info.match(/END=(\\d+)/)?.[1].trim() || start + ref.length)\n        return { line, refName, start, end, id }\n      })\n      .reduce((acc, obj) => {\n        const key = obj.refName\n        if (!acc[key]) {\n          acc[key] = new IntervalTree()\n        }\n        acc[key].insert([obj.start, obj.end], obj)\n        return acc\n      }, {} as Record<string, IntervalTree>)\n\n    return { header, intervalTree }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch(e => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTree } = await this.setup()\n    return Object.keys(intervalTree)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { header, intervalTree } = await this.setup()\n        const parser = new VCF({ header: header })\n        intervalTree[refName]?.search([start, end]).forEach(f =>\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(f.line),\n              parser,\n              id: `${this.id}-${f.id}`,\n            }),\n          ),\n        )\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n/**\r\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\r\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\r\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\r\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\r\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\r\n * This interface is described in typescript definition file *index.d.ts*\r\n *\r\n * Axis aligned rectangle is an example of such interval.\r\n * We may look at rectangle as an interval between its low left and top right corners.\r\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\r\n * of Interval interface implementation\r\n * @type {Interval}\r\n */\r\nconst Interval = class Interval {\r\n    /**\r\n     * Accept two comparable values and creates new instance of interval\r\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\r\n     * @param low\r\n     * @param high\r\n     */\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    /**\r\n     * Clone interval\r\n     * @returns {Interval}\r\n     */\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    /**\r\n     * Propery max returns clone of this interval\r\n     * @returns {Interval}\r\n     */\r\n    get max() {\r\n        return this.clone();   // this.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval less than other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval equals to other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval intersects other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval does not intersect other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    /**\r\n     * Returns new interval merged with other interval\r\n     * @param {Interval} interval - Other interval to merge with\r\n     * @returns {Interval}\r\n     */\r\n    merge(other_interval) {\r\n        return new Interval(\r\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\r\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns how key should return\r\n     */\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    /**\r\n     * Function returns maximum between two comparable values\r\n     * @param interval1\r\n     * @param interval2\r\n     * @returns {Interval}\r\n     */\r\n    static comparable_max(interval1, interval2) {\r\n        return interval1.merge(interval2);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if first value less than second value\r\n     * @param val1\r\n     * @param val2\r\n     * @returns {boolean}\r\n     */\r\n    static comparable_less_than(val1, val2 ) {\r\n        return val1 < val2;\r\n    }\r\n};\n\n/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n// module.exports = {\r\n//     RB_TREE_COLOR_RED: 0,\r\n//     RB_TREE_COLOR_BLACK: 1\r\n// };\r\n\r\nconst RB_TREE_COLOR_RED = 0;\r\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nclass Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.less_than(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_less_than = this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n                this.item.value < other_node.item.value;\r\n            return this.item.key.less_than(other_node.item.key) ||\r\n                this.item.key.equal_to((other_node.item.key)) && value_less_than;\r\n        }\r\n\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     let item_less_than = this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n        //         this.item.value < other_node.item.value;\r\n        //     return this.item.key.less_than(other_node.item.key) ||\r\n        //         this.item.key.equal_to((other_node.item.key)) && item_less_than;\r\n        // }\r\n        // else {\r\n        //     return this.item.key.less_than(other_node.item.key);\r\n        // }\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.equal_to(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_equal = this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n            return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n        }\r\n\r\n        // let value_equal = true;\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n        //         this.item.value == other_node.item.value;\r\n        // }\r\n        // return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key.clone();\r\n        this.item.value = other_node.item.value && other_node.item.value.clone ? other_node.item.value.clone() : other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\r\n        return comparable_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\r\n        return comparable_less_than(search_node.item.key.high, low);\r\n    }\r\n}\n\n/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n\r\n// const nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\r\n * @type {IntervalTree}\r\n */\r\nclass IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n        this.nil_node = new Node();\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Returns array of sorted keys in the ascending order\r\n     * @returns {Array}\r\n     */\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(\r\n            node.item.key.output ? node.item.key.output() : node.item.key\r\n        ));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Return array of values in the ascending keys order\r\n     * @returns {Array}\r\n     */\r\n    get values() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns array of items (<key,value> pairs) in the ascended keys order\r\n     * @returns {Array}\r\n     */\r\n    get items() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push({\r\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\r\n            value: node.item.value\r\n        }));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns true if tree is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return (this.root == null || this.root == this.nil_node);\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param {Interval} key - interval object or array of two numbers [low, high]\r\n     * @param {any} value - value representing any object (optional)\r\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object to be checked\r\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object\r\n     * @returns {boolean} true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param {Interval} interval - search interval, or tuple [low, high]\r\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\r\n     * @returns {Array}\r\n     */\r\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersection between given and any interval stored in the tree found\r\n     * @param {Interval} interval - search interval or tuple [low, high]\r\n     * @returns {boolean}\r\n     */\r\n    intersect_any(interval) {\r\n        let search_node = new Node(interval);\r\n        let found = this.tree_find_any_interval(this.root, search_node);\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    }\r\n\r\n    /** Value Mapper. Walk through every node and map node value to another value\r\n    * @param callback(value,key) - function to be called for each tree item\r\n    */\r\n    map(callback) {\r\n        const tree = new IntervalTree();\r\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\r\n        return tree;\r\n    }\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == this.nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != this.nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != this.nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != this.nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == this.nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    tree_find_any_interval(node, search_node) {\r\n        let found = false;\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.left, search_node);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (!found) {\r\n                found = node.intersect(search_node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.right, search_node);\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != this.nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != this.nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != this.nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != this.nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != this.nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != this.nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.toArray());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != this.nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != this.nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n}\n\nexport default IntervalTree;\nexport { Node, Interval };\n"],"sourceRoot":""}