{"version":3,"sources":["../../../node_modules/pako/lib/utils/strings.js","../../../node_modules/pako/index.js","../../../node_modules/pako/lib/deflate.js","../../../node_modules/pako/lib/inflate.js","../../../node_modules/pako/lib/zlib/gzheader.js"],"names":["utils","require","STR_APPLY_OK","STR_APPLY_UIA_OK","String","fromCharCode","apply","__","Uint8Array","_utf8len","Buf8","q","buf2binstring","buf","len","subarray","shrinkBuf","result","i","exports","string2buf","str","c","c2","m_pos","str_len","length","buf_len","charCodeAt","binstring2buf","buf2string","max","out","c_len","utf16buf","Array","utf8border","pos","pako","assign","module","zlib_deflate","strings","msg","ZStream","toString","Object","prototype","Deflate","options","this","level","method","chunkSize","windowBits","memLevel","strategy","to","opt","raw","gzip","err","ended","chunks","strm","avail_out","status","deflateInit2","Error","header","deflateSetHeader","dictionary","dict","call","deflateSetDictionary","_dict_set","deflate","input","deflator","push","data","mode","_mode","next_in","avail_in","output","next_out","onEnd","onData","deflateEnd","chunk","join","flattenChunks","deflateRaw","zlib_inflate","GZheader","Inflate","inflateInit2","Z_OK","inflateGetHeader","inflateSetDictionary","inflate","inflator","next_out_utf8","tail","utf8str","allowBufError","Z_FINISH","Z_NO_FLUSH","Z_NEED_DICT","Z_BUF_ERROR","Z_STREAM_END","Z_SYNC_FLUSH","arraySet","inflateEnd","inflateRaw","ungzip","text","time","xflags","os","extra","extra_len","name","comment","hcrc","done"],"mappings":"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","file":"static/js/2.486360b1.chunk.js","sourcesContent":["// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n"],"sourceRoot":""}