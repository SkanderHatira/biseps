{"version":3,"sources":["../../../node_modules/@gmod/indexedfasta/esm/indexedFasta.js","../../../node_modules/@gmod/indexedfasta/esm/index.js","../../../node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js","../../../packages/core/util/QuickLRU.js","../../../plugins/sequence/src/IndexedFastaAdapter/IndexedFastaAdapter.ts","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js"],"names":["Object","defineProperty","exports","value","generic_filehandle_1","require","_faiOffset","idx","pos","offset","lineBytes","Math","floor","lineLength","readFAI","fai","opts","readFile","text","length","Error","idCounter","data","toString","split","filter","line","test","map","row","currSeq","name","id","start","end","fromEntries","entry","IndexedFasta","fasta","path","faiPath","chunkSizeLimit","this","LocalFile","indexes","_getIndexes","keys","returnObject","vals","values","i","seqName","_a","seqId","min","max","indexEntry","undefined","_fetchFromIndexEntry","getResiduesByName","TypeError","position","readlen","toLocaleString","residues","Buffer","allocUnsafe","read","replace","default","__importDefault","mod","__esModule","BgzipIndexedFasta","FetchableSmallFasta","parseSmallFasta","object_fromentries_1","bgzipIndexedFasta_1","indexedFasta_1","t","entryText","defLine","seqLines","description","sequence","join","shim","then","buffer","find","iter","substr","bgzf_filehandle_1","gzi","gziPath","BgzfFilehandle","filehandle","gziFilehandle","QuickLRU","options","_classCallCheck","maxSize","cache","Map","oldCache","_size","key","set","has","get","delete","_set","deleted","clear","_iterator","_context","_step$value","_iterator2","_context2","_step2$value","_iterator3","_context3","item","_iterator4","_item2","oldCacheSize","_iterator5","Symbol","iterator","config","getSubAdapter","pluginManager","seqCache","AbortablePromiseCache","LRU","fill","args","signal","a","refName","getSequence","fastaLocation","readConfObject","faiLocation","fastaOpts","openLocation","getSequenceNames","getSequenceSizes","seqSizes","region","ObservableCreate","observer","getSequenceSize","size","regionEnd","chunks","e","chunkSize","chunkStart","s","r","push","JSON","stringify","Promise","all","seq","slice","next","SimpleFeature","complete","BaseSequenceAdapter","AbortSignal","AbortController","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1","abortcontroller_ponyfill_1","AggregateAbortController_1","AggregateStatusReporter_1","fillCallback","statusCallback","aborter","statusReporter","addCallback","newEntry","promise","message","callback","settled","aborted","addSignal","addEventListener","evict","catch","console","error","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","deleteCount","result","done","exception","code","checkForSingleAbort","assign","NullSignal","AggregateAbortController","signals","Set","abortController","add","handleAborted","AggregateStatusReporter","callbacks","currentMessage","forEach","elt"],"mappings":"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","file":"20.aa3f117980c15500c977.worker.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nfunction _faiOffset(idx, pos) {\n    return (idx.offset +\n        idx.lineBytes * Math.floor(pos / idx.lineLength) +\n        (pos % idx.lineLength));\n}\nasync function readFAI(fai, opts) {\n    const text = await fai.readFile(opts);\n    if (!(text && text.length)) {\n        throw new Error('No data read from FASTA index (FAI) file');\n    }\n    let idCounter = 0;\n    let currSeq;\n    const data = text\n        .toString('utf8')\n        .split(/\\r?\\n/)\n        .filter(line => /\\S/.test(line))\n        .map(line => line.split('\\t'))\n        .filter(row => row[0] !== '')\n        .map(row => {\n        if (!currSeq || currSeq.name !== row[0]) {\n            currSeq = { name: row[0], id: idCounter };\n            idCounter += 1;\n        }\n        return {\n            id: currSeq.id,\n            name: row[0],\n            length: +row[1],\n            start: 0,\n            end: +row[1],\n            offset: +row[2],\n            lineLength: +row[3],\n            lineBytes: +row[4],\n        };\n    });\n    return {\n        name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n        id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n    };\n}\nclass IndexedFasta {\n    constructor({ fasta, fai, path, faiPath, chunkSizeLimit = 1000000, }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new generic_filehandle_1.LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass filehandle for fasta or path to localfile');\n        }\n        if (fai) {\n            this.fai = fai;\n        }\n        else if (faiPath) {\n            this.fai = new generic_filehandle_1.LocalFile(faiPath);\n        }\n        else if (path) {\n            this.fai = new generic_filehandle_1.LocalFile(`${path}.fai`);\n        }\n        else {\n            throw new Error('Need to pass filehandle for  or path to localfile');\n        }\n        this.chunkSizeLimit = chunkSizeLimit;\n    }\n    async _getIndexes(opts) {\n        if (!this.indexes) {\n            this.indexes = readFAI(this.fai, opts);\n        }\n        return this.indexes;\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceNames(opts) {\n        return Object.keys((await this._getIndexes(opts)).name);\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceSizes(opts) {\n        const returnObject = {};\n        const idx = await this._getIndexes(opts);\n        const vals = Object.values(idx.id);\n        for (let i = 0; i < vals.length; i += 1) {\n            returnObject[vals[i].name] = vals[i].length;\n        }\n        return returnObject;\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceSize(seqName, opts) {\n        var _a;\n        const idx = await this._getIndexes(opts);\n        return (_a = idx.name[seqName]) === null || _a === void 0 ? void 0 : _a.length;\n    }\n    /**\n     *\n     * @param {string} name\n     * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n     */\n    async hasReferenceSequence(name, opts) {\n        return !!(await this._getIndexes(opts)).name[name];\n    }\n    /**\n     *\n     * @param {number} seqId\n     * @param {number} min\n     * @param {number} max\n     */\n    async getResiduesById(seqId, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts)).id[seqId];\n        if (!indexEntry) {\n            return undefined;\n        }\n        return this._fetchFromIndexEntry(indexEntry, min, max, opts);\n    }\n    /**\n     * @param {string} seqName\n     * @param {number} min\n     * @param {number} max\n     */\n    async getResiduesByName(seqName, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts)).name[seqName];\n        if (!indexEntry) {\n            return undefined;\n        }\n        return this._fetchFromIndexEntry(indexEntry, min, max, opts);\n    }\n    //alias for getResiduesByName\n    async getSequence(seqName, min, max, opts) {\n        return this.getResiduesByName(seqName, min, max, opts);\n    }\n    async _fetchFromIndexEntry(indexEntry, min = 0, max, opts) {\n        let end = max;\n        if (min < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        if (end === undefined || end > indexEntry.length) {\n            end = indexEntry.length;\n        }\n        if (min >= end) {\n            return '';\n        }\n        const position = _faiOffset(indexEntry, min);\n        const readlen = _faiOffset(indexEntry, end) - position;\n        if (readlen > this.chunkSizeLimit) {\n            throw new Error(`data size of ${readlen.toLocaleString()} bytes exceeded chunk size limit of ${this.chunkSizeLimit.toLocaleString()} bytes`);\n        }\n        const residues = Buffer.allocUnsafe(readlen);\n        await this.fasta.read(residues, 0, readlen, position, opts);\n        return residues.toString('utf8').replace(/\\s+/g, '');\n    }\n}\nexports.default = IndexedFasta;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BgzipIndexedFasta = exports.IndexedFasta = exports.FetchableSmallFasta = exports.parseSmallFasta = void 0;\nconst object_fromentries_1 = __importDefault(require(\"object.fromentries\"));\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nconst bgzipIndexedFasta_1 = __importDefault(require(\"./bgzipIndexedFasta\"));\nexports.BgzipIndexedFasta = bgzipIndexedFasta_1.default;\nconst indexedFasta_1 = __importDefault(require(\"./indexedFasta\"));\nexports.IndexedFasta = indexedFasta_1.default;\nif (!Object.fromEntries) {\n    // @ts-ignore\n    object_fromentries_1.default.shim();\n}\nfunction parseSmallFasta(text) {\n    return text\n        .split('>')\n        .filter(t => /\\S/.test(t))\n        .map(entryText => {\n        const [defLine, ...seqLines] = entryText.split('\\n');\n        const [id, ...description] = defLine.split(' ');\n        const sequence = seqLines.join('').replace(/\\s/g, '');\n        return {\n            id,\n            description: description.join(' '),\n            sequence,\n        };\n    });\n}\nexports.parseSmallFasta = parseSmallFasta;\n// memoized\nclass FetchableSmallFasta {\n    constructor({ fasta, path }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new generic_filehandle_1.LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass fasta or path');\n        }\n        this.data = this.fasta.readFile().then(buffer => {\n            const text = buffer.toString('utf8');\n            return parseSmallFasta(text);\n        });\n    }\n    async fetch(id, start, end) {\n        const data = await this.data;\n        const entry = data.find(iter => iter.id === id);\n        const length = end - start;\n        if (!entry) {\n            throw new Error(`no sequence with id ${id} exists`);\n        }\n        return entry.sequence.substr(start, length);\n    }\n    async getSequenceNames() {\n        const data = await this.data;\n        return data.map(entry => entry.id);\n    }\n}\nexports.FetchableSmallFasta = FetchableSmallFasta;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst indexedFasta_1 = __importDefault(require(\"./indexedFasta\"));\nclass BgzipIndexedFasta extends indexedFasta_1.default {\n    constructor({ fasta, path, fai, faiPath, gzi, gziPath, chunkSizeLimit, }) {\n        super({ fasta, path, fai, faiPath, chunkSizeLimit });\n        if (fasta && gzi) {\n            this.fasta = new bgzf_filehandle_1.BgzfFilehandle({\n                filehandle: fasta,\n                gziFilehandle: gzi,\n            });\n        }\n        else if (path && gziPath) {\n            this.fasta = new bgzf_filehandle_1.BgzfFilehandle({ path, gziPath });\n        }\n    }\n}\nexports.default = BgzipIndexedFasta;\n","/* eslint-disable no-underscore-dangle */\n/**\n * Heavily based on [quick-lru](https://www.npmjs.com/package/quick-lru)\n * (quick-lru didn't work for us because the export wouldn't compile in Webpack\n * properly)\n */\nclass QuickLRU {\n  constructor(options = {}) {\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set(key, value) {\n    this.cache.set(key, value)\n    this._size += 1\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n\n    return undefined\n  }\n\n  set(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has(key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  peek(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      return this.oldCache.get(key)\n    }\n\n    return undefined\n  }\n\n  delete(key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size -= 1\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear() {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  *keys() {\n    for (const [key] of this) {\n      yield key\n    }\n  }\n\n  *values() {\n    for (const [, value] of this) {\n      yield value\n    }\n  }\n\n  *[Symbol.iterator]() {\n    for (const item of this.cache) {\n      yield item\n    }\n\n    for (const item of this.oldCache) {\n      const [key] = item\n      if (!this.cache.has(key)) {\n        yield item\n      }\n    }\n  }\n\n  get size() {\n    let oldCacheSize = 0\n    for (const key of this.oldCache.keys()) {\n      if (!this.cache.has(key)) {\n        oldCacheSize += 1\n      }\n    }\n\n    return this._size + oldCacheSize\n  }\n}\n\nexport default QuickLRU\n","import { IndexedFasta } from '@gmod/indexedfasta'\nimport {\n  BaseSequenceAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { FileLocation, NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration/configurationSchema'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport LRU from '@jbrowse/core/util/QuickLRU'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\nexport default class extends BaseSequenceAdapter {\n  protected fasta: IndexedFasta\n\n  private seqCache = new AbortablePromiseCache({\n    cache: new LRU({ maxSize: 200 }),\n    fill: async (\n      args: { refName: string; start: number; end: number },\n      signal?: AbortSignal,\n    ) => {\n      const { refName, start, end } = args\n      return this.fasta.getSequence(refName, start, end, { ...args, signal })\n    },\n  })\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const fastaLocation = readConfObject(config, 'fastaLocation')\n    const faiLocation = readConfObject(config, 'faiLocation')\n    const fastaOpts = {\n      fasta: openLocation(fastaLocation as FileLocation, this.pluginManager),\n      fai: openLocation(faiLocation as FileLocation, this.pluginManager),\n    }\n\n    this.fasta = new IndexedFasta(fastaOpts)\n  }\n\n  public getRefNames(opts?: BaseOptions) {\n    return this.fasta.getSequenceNames(opts)\n  }\n\n  public async getRegions(opts?: BaseOptions) {\n    const seqSizes = await this.fasta.getSequenceSizes(opts)\n    return Object.keys(seqSizes).map(refName => ({\n      refName,\n      start: 0,\n      end: seqSizes[refName],\n    }))\n  }\n\n  public getFeatures(region: NoAssemblyRegion, opts?: BaseOptions) {\n    const { refName, start, end } = region\n    return ObservableCreate<Feature>(async observer => {\n      const size = await this.fasta.getSequenceSize(refName, opts)\n      const regionEnd = size !== undefined ? Math.min(size, end) : end\n      const chunks = []\n      const chunkSize = 128000\n\n      const s = start - (start % chunkSize)\n      const e = end + (chunkSize - (end % chunkSize))\n      for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n        const r = {\n          refName,\n          start: chunkStart,\n          end: chunkStart + chunkSize,\n        }\n        chunks.push(this.seqCache.get(JSON.stringify(r), r, opts?.signal))\n      }\n      const seq = (await Promise.all(chunks))\n        .join('')\n        .slice(start - s)\n        .slice(0, end - start)\n      if (seq) {\n        observer.next(\n          new SimpleFeature({\n            id: `${refName} ${start}-${regionEnd}`,\n            data: { refName, start, end: regionEnd, seq },\n          }),\n        )\n      }\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the forseeable future and can be purged\n   * from caches, etc\n   */\n  public freeResources(/* { region } */): void {}\n}\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n"],"sourceRoot":""}