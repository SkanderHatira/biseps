{"version":3,"sources":["../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../../../node_modules/@gmod/tabix/esm/index.js","../../../node_modules/@gmod/tabix/esm/tabixIndexedFile.js","../../../plugins/variants/src/VcfTabixAdapter/VcfTabixAdapter.ts","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js","../../../node_modules/long/src/long.js","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/quick-lru/index.js","../../../node_modules/@gmod/tabix/esm/util.js","../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/@gmod/tabix/esm/tbi.js","../../../node_modules/@gmod/tabix/esm/virtualOffset.js","../../../node_modules/@gmod/tabix/esm/chunk.js","../../../node_modules/@gmod/tabix/esm/indexFile.js","../../../node_modules/@gmod/tabix/esm/csi.js"],"names":["objectWithoutPropertiesLoose","module","exports","source","excluded","key","i","target","Object","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","prototype","propertyIsEnumerable","call","__esModule","__importDefault","this","mod","defineProperty","value","CSI","TBI","TabixIndexedFile","tabixIndexedFile_1","require","default","tbi_1","csi_1","abortable_promise_cache_1","quick_lru_1","generic_filehandle_1","bgzf_filehandle_1","util_1","timeout","time","Promise","resolve","setTimeout","path","filehandle","tbiPath","tbiFilehandle","csiPath","csiFilehandle","chunkSizeLimit","renameRefSeqs","n","chunkCacheSize","TypeError","LocalFile","index","renameRefSeq","chunkCache","cache","maxSize","Math","floor","fill","readChunk","bind","refName","start","end","opts","options","callback","lineCallback","undefined","getMetadata","metadata","checkAbortSignal","signal","maxRefLength","blocksForRange","chunks","size","fetchedSize","Error","toLocaleString","last","Date","now","chunkNum","previousStartCoordinate","c","get","toString","buffer","cpositions","dpositions","lines","TextDecoder","decode","split","pop","blockStart","minv","dataPosition","pos","line","checkLine","startCoordinate","overlaps","trim","firstDataLine","metaChar","maxBlockSize","maxFetch","blockPosition","_readRegion","bytes","unzip","console","error","code","lastNewline","newlineByte","charCodeAt","metaByte","slice","getHeaderBuffer","refIdToName","regionRefName","regionStart","regionEnd","columnNumbers","coordinateType","format","charAt","ref","maxColumn","max","currentColumnNumber","currentColumnStart","refSeq","Infinity","parseInt","_getVcfEnd","info","endCoordinate","isTRA","prevChar","j","valueEnd","lineCount","position","compressedSize","read","Buffer","alloc","bytesRead","chunk","compressedData","unzipChunkSlice","configured","vcfGzLocation","readConfObject","config","location","indexType","openLocation","pluginManager","isCSI","vcf","getHeader","header","parser","VcfParser","configurePre","catch","e","configure","getReferenceSequenceNames","a","query","ObservableCreate","observer","getLines","fileOffset","next","VcfFeature","variant","parseLine","id","complete","regions","superGetFeaturesInMultipleRegions","bytesForRegions","stat","pct","round","warn","subscribe","BaseFeatureDataAdapter","AbortSignal","AbortController","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1","Long","wasm","WebAssembly","Instance","Module","Uint8Array","low","high","unsigned","isLong","obj","__isLong__","INT_CACHE","UINT_CACHE","fromInt","cachedObj","fromBits","fromNumber","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","pow","fromString","str","radix","RangeError","p","substring","radixToPower","result","min","power","mul","add","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","toNumber","isZero","isNegative","eq","radixLong","div","rem1","sub","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","equals","other","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","compare","thisNeg","otherNeg","negate","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","get_high","b00","divide","divisor","approx","res","div_u","div_s","toUnsigned","shru","shr","shl","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","rem_u","rem_s","and","or","xor","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","toSigned","toBytes","toBytesLE","toBytesBE","hi","lo","fromBytes","fromBytesLE","fromBytesBE","abortcontroller_ponyfill_1","AggregateAbortController_1","AggregateStatusReporter_1","AbortablePromiseCache","set","delete","fillCallback","entry","data","statusCallback","aborter","statusReporter","addCallback","newEntry","promise","message","settled","aborted","addSignal","addEventListener","evict","then","has","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","keys","deleteCount","done","exception","name","checkForSingleAbort","assign","NullSignal","AggregateAbortController","signals","Set","abortController","handleAborted","AggregateStatusReporter","callbacks","currentMessage","forEach","elt","QuickLRU","Map","oldCache","_size","_set","deleted","clear","item","oldCacheSize","Symbol","iterator","optimizeChunks","canMergeBlocks","abortBreakPoint","longToNumber","long","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","AbortError","DOMException","chunk1","chunk2","maxv","lowest","mergedChunks","lastChunk","sort","c0","c1","dif","compareTo","push","sourceKeys","__createBinding","create","o","m","k","k2","enumerable","__setModuleDefault","v","__importStar","hasOwnProperty","long_1","virtualOffset_1","chunk_1","indexFile_1","TBI_MAGIC","reg2bins","beg","TabixIndex","parse","indexData","refId","refNameToId","indices","stats","readFile","readUInt32LE","refCount","readInt32LE","formatFlags","metaValue","maxBinNumber","depth","String","fromCharCode","skipLines","nameSectionLength","_parseNameBytes","currOffset","Array","map","binCount","binIndex","bin","chunkCount","parsePseudoBin","u","_findFirstData","linearCount","linearIndex","offset","namesBytes","currRefId","currNameStart","ba","overlappingBins","binChunks","nintv","minLin","maxLin","vp","VirtualOffset","b","args","bigendian","Chunk","_fetchedSize","toUniqueString","IndexFile","rest","currentFdl","virtualOffset","_parseCache","_parse","seqId","CSI1_MAGIC","CSI2_MAGIC","rshift","num","bits","minShift","auxLength","csiVersion","aux","parseAuxData","loffset","csi","l","t","s","bins"],"mappings":"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AG,EAAG,IAAK,GAAI,EAAG,IAAK,IAAK,IAAK,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,IAAK,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,EAAG,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IA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","file":"13.aa3f117980c15500c977.worker.js","sourcesContent":["var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CSI = exports.TBI = exports.TabixIndexedFile = void 0;\nconst tabixIndexedFile_1 = __importDefault(require(\"./tabixIndexedFile\"));\nexports.TabixIndexedFile = tabixIndexedFile_1.default;\nconst tbi_1 = __importDefault(require(\"./tbi\"));\nexports.TBI = tbi_1.default;\nconst csi_1 = __importDefault(require(\"./csi\"));\nexports.CSI = csi_1.default;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortable_promise_cache_1 = __importDefault(require(\"abortable-promise-cache\"));\nconst quick_lru_1 = __importDefault(require(\"quick-lru\"));\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst util_1 = require(\"./util\");\nconst tbi_1 = __importDefault(require(\"./tbi\"));\nconst csi_1 = __importDefault(require(\"./csi\"));\nfunction timeout(time) {\n    return new Promise(resolve => {\n        setTimeout(resolve, time);\n    });\n}\nclass TabixIndexedFile {\n    /**\n     * @param {object} args\n     * @param {string} [args.path]\n     * @param {filehandle} [args.filehandle]\n     * @param {string} [args.tbiPath]\n     * @param {filehandle} [args.tbiFilehandle]\n     * @param {string} [args.csiPath]\n     * @param {filehandle} [args.csiFilehandle]\n     * @param {chunkSizeLimit} default 50MiB\n     * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform\n     * reference sequence names for the purpose of indexing and querying. note that the data that is returned is\n     * not altered, just the names of the reference sequences that are used for querying.\n     * @param {number} [args.chunkCacheSize] maximum size in bytes of the chunk cache. default 5MB\n     * @param {number} [args.blockCacheSize] maximum size in bytes of the block cache. default 5MB\n     */\n    constructor({ path, filehandle, tbiPath, tbiFilehandle, csiPath, csiFilehandle, chunkSizeLimit = 50000000, renameRefSeqs = n => n, chunkCacheSize = 5 * 2 ** 20, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new generic_filehandle_1.LocalFile(path);\n        }\n        else {\n            throw new TypeError('must provide either filehandle or path');\n        }\n        if (tbiFilehandle) {\n            this.index = new tbi_1.default({\n                filehandle: tbiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (csiFilehandle) {\n            this.index = new csi_1.default({\n                filehandle: csiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (tbiPath) {\n            this.index = new tbi_1.default({\n                filehandle: new generic_filehandle_1.LocalFile(tbiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (csiPath) {\n            this.index = new csi_1.default({\n                filehandle: new generic_filehandle_1.LocalFile(csiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (path) {\n            this.index = new tbi_1.default({\n                filehandle: new generic_filehandle_1.LocalFile(`${path}.tbi`),\n                renameRefSeqs,\n            });\n        }\n        else {\n            throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath');\n        }\n        this.chunkSizeLimit = chunkSizeLimit;\n        this.renameRefSeq = renameRefSeqs;\n        this.chunkCache = new abortable_promise_cache_1.default({\n            cache: new quick_lru_1.default({\n                maxSize: Math.floor(chunkCacheSize / (1 << 16)),\n            }),\n            fill: this.readChunk.bind(this),\n        });\n    }\n    /**\n     * @param {string} refName name of the reference sequence\n     * @param {number} start start of the region (in 0-based half-open coordinates)\n     * @param {number} end end of the region (in 0-based half-open coordinates)\n     * @param {function|object} lineCallback callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc\n     * @returns {Promise} resolved when the whole read is finished, rejected on error\n     */\n    async getLines(refName, start, end, opts) {\n        let signal;\n        let options = {};\n        let callback;\n        if (typeof opts === 'undefined') {\n            throw new TypeError('line callback must be provided');\n        }\n        if (typeof opts === 'function') {\n            callback = opts;\n        }\n        else {\n            options = opts;\n            callback = opts.lineCallback;\n        }\n        if (refName === undefined) {\n            throw new TypeError('must provide a reference sequence name');\n        }\n        if (!callback) {\n            throw new TypeError('line callback must be provided');\n        }\n        const metadata = await this.index.getMetadata(options);\n        (0, util_1.checkAbortSignal)(signal);\n        if (!start) {\n            start = 0;\n        }\n        if (!end) {\n            end = metadata.maxRefLength;\n        }\n        if (!(start <= end)) {\n            throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');\n        }\n        if (start === end) {\n            return;\n        }\n        const chunks = await this.index.blocksForRange(refName, start, end, options);\n        (0, util_1.checkAbortSignal)(signal);\n        // check the chunks for any that are over the size limit.  if\n        // any are, don't fetch any of them\n        for (let i = 0; i < chunks.length; i += 1) {\n            const size = chunks[i].fetchedSize();\n            if (size > this.chunkSizeLimit) {\n                throw new Error(`Too much data. Chunk size ${size.toLocaleString()} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit.toLocaleString()}.`);\n            }\n        }\n        // now go through each chunk and parse and filter the lines out of it\n        let last = Date.now();\n        for (let chunkNum = 0; chunkNum < chunks.length; chunkNum += 1) {\n            let previousStartCoordinate;\n            const c = chunks[chunkNum];\n            const { buffer, cpositions, dpositions } = await this.chunkCache.get(c.toString(), c, signal);\n            const lines = (typeof TextDecoder !== 'undefined'\n                ? new TextDecoder('utf-8').decode(buffer)\n                : buffer.toString()).split('\\n');\n            lines.pop();\n            (0, util_1.checkAbortSignal)(signal);\n            let blockStart = c.minv.dataPosition;\n            let pos;\n            for (let i = 0; i < lines.length; i += 1) {\n                const line = lines[i];\n                for (pos = 0; blockStart >= dpositions[pos]; pos += 1) { }\n                // filter the line for whether it is within the requested range\n                const { startCoordinate, overlaps } = this.checkLine(metadata, refName, start, end, line);\n                // do a small check just to make sure that the lines are really sorted by start coordinate\n                if (previousStartCoordinate !== undefined &&\n                    startCoordinate !== undefined &&\n                    previousStartCoordinate > startCoordinate) {\n                    throw new Error(`Lines not sorted by start coordinate (${previousStartCoordinate} > ${startCoordinate}), this file is not usable with Tabix.`);\n                }\n                previousStartCoordinate = startCoordinate;\n                if (overlaps) {\n                    callback(line.trim(), \n                    // cpositions[pos] refers to actual file offset of a bgzip block boundaries\n                    //\n                    // we multiply by (1 <<8) in order to make sure each block has a \"unique\"\n                    // address space so that data in that block could never overlap\n                    //\n                    // then the blockStart-dpositions is an uncompressed file offset from\n                    // that bgzip block boundary, and since the cpositions are multiplied by\n                    // (1 << 8) these uncompressed offsets get a unique space\n                    cpositions[pos] * (1 << 8) + (blockStart - dpositions[pos]));\n                }\n                else if (startCoordinate !== undefined && startCoordinate >= end) {\n                    // the lines were overlapping the region, but now have stopped, so\n                    // we must be at the end of the relevant data and we can stop\n                    // processing data now\n                    return;\n                }\n                blockStart += line.length + 1;\n                // yield if we have emitted beyond the yield limit\n                if (last - Date.now() > 500) {\n                    last = Date.now();\n                    (0, util_1.checkAbortSignal)(signal);\n                    await timeout(1);\n                }\n            }\n        }\n    }\n    async getMetadata(opts = {}) {\n        return this.index.getMetadata(opts);\n    }\n    /**\n     * get a buffer containing the \"header\" region of\n     * the file, which are the bytes up to the first\n     * non-meta line\n     *\n     * @returns {Promise} for a buffer\n     */\n    async getHeaderBuffer(opts = {}) {\n        const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(opts);\n        (0, util_1.checkAbortSignal)(opts.signal);\n        const maxFetch = firstDataLine && firstDataLine.blockPosition\n            ? firstDataLine.blockPosition + maxBlockSize\n            : maxBlockSize;\n        // TODO: what if we don't have a firstDataLine, and the header\n        // actually takes up more than one block? this case is not covered here\n        let bytes = await this._readRegion(0, maxFetch, opts);\n        (0, util_1.checkAbortSignal)(opts.signal);\n        try {\n            bytes = await (0, bgzf_filehandle_1.unzip)(bytes);\n        }\n        catch (e) {\n            console.error(e);\n            throw new Error(\n            //@ts-ignore\n            `error decompressing block ${e.code} at 0 (length ${maxFetch}) ${e}`);\n        }\n        // trim off lines after the last non-meta line\n        if (metaChar) {\n            // trim backward from the end\n            let lastNewline = -1;\n            const newlineByte = '\\n'.charCodeAt(0);\n            const metaByte = metaChar.charCodeAt(0);\n            for (let i = 0; i < bytes.length; i += 1) {\n                if (i === lastNewline + 1 && bytes[i] !== metaByte) {\n                    break;\n                }\n                if (bytes[i] === newlineByte) {\n                    lastNewline = i;\n                }\n            }\n            bytes = bytes.slice(0, lastNewline + 1);\n        }\n        return bytes;\n    }\n    /**\n     * get a string containing the \"header\" region of the\n     * file, is the portion up to the first non-meta line\n     *\n     * @returns {Promise} for a string\n     */\n    async getHeader(opts = {}) {\n        const bytes = await this.getHeaderBuffer(opts);\n        (0, util_1.checkAbortSignal)(opts.signal);\n        return bytes.toString('utf8');\n    }\n    /**\n     * get an array of reference sequence names, in the order in which\n     * they occur in the file.\n     *\n     * reference sequence renaming is not applied to these names.\n     *\n     * @returns {Promise} for an array of string sequence names\n     */\n    async getReferenceSequenceNames(opts = {}) {\n        const metadata = await this.getMetadata(opts);\n        return metadata.refIdToName;\n    }\n    /**\n     * @param {object} metadata metadata object from the parsed index,\n     * containing columnNumbers, metaChar, and format\n     * @param {string} regionRefName\n     * @param {number} regionStart region start coordinate (0-based-half-open)\n     * @param {number} regionEnd region end coordinate (0-based-half-open)\n     * @param {array[string]} line\n     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,\n     * true if line is a data line that overlaps the given region\n     */\n    checkLine({ columnNumbers, metaChar, coordinateType, format, }, regionRefName, regionStart, regionEnd, line) {\n        // skip meta lines\n        if (line.charAt(0) === metaChar) {\n            return { overlaps: false };\n        }\n        // check ref/start/end using column metadata from index\n        let { ref, start, end } = columnNumbers;\n        if (!ref) {\n            ref = 0;\n        }\n        if (!start) {\n            start = 0;\n        }\n        if (!end) {\n            end = 0;\n        }\n        if (format === 'VCF') {\n            end = 8;\n        }\n        const maxColumn = Math.max(ref, start, end);\n        // this code is kind of complex, but it is fairly fast.\n        // basically, we want to avoid doing a split, because if the lines are really long\n        // that could lead to us allocating a bunch of extra memory, which is slow\n        let currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata\n        let currentColumnStart = 0;\n        let refSeq = '';\n        let startCoordinate = -Infinity;\n        for (let i = 0; i < line.length + 1; i += 1) {\n            if (line[i] === '\\t' || i === line.length) {\n                if (currentColumnNumber === ref) {\n                    if (this.renameRefSeq(line.slice(currentColumnStart, i)) !==\n                        regionRefName) {\n                        return { overlaps: false };\n                    }\n                }\n                else if (currentColumnNumber === start) {\n                    startCoordinate = parseInt(line.slice(currentColumnStart, i), 10);\n                    // we convert to 0-based-half-open\n                    if (coordinateType === '1-based-closed') {\n                        startCoordinate -= 1;\n                    }\n                    if (startCoordinate >= regionEnd) {\n                        return { startCoordinate, overlaps: false };\n                    }\n                    if (end === 0 || end === start) {\n                        // if we have no end, we assume the feature is 1 bp long\n                        if (startCoordinate + 1 <= regionStart) {\n                            return { startCoordinate, overlaps: false };\n                        }\n                    }\n                }\n                else if (format === 'VCF' && currentColumnNumber === 4) {\n                    refSeq = line.slice(currentColumnStart, i);\n                }\n                else if (currentColumnNumber === end) {\n                    let endCoordinate;\n                    // this will never match if there is no end column\n                    if (format === 'VCF') {\n                        endCoordinate = this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i));\n                    }\n                    else {\n                        endCoordinate = parseInt(line.slice(currentColumnStart, i), 10);\n                    }\n                    if (endCoordinate <= regionStart) {\n                        return { overlaps: false };\n                    }\n                }\n                currentColumnStart = i + 1;\n                currentColumnNumber += 1;\n                if (currentColumnNumber > maxColumn) {\n                    break;\n                }\n            }\n        }\n        return { startCoordinate, overlaps: true };\n    }\n    _getVcfEnd(startCoordinate, refSeq, info) {\n        let endCoordinate = startCoordinate + refSeq.length;\n        // ignore TRA features as they specify CHR2 and END\n        // as being on a different chromosome\n        // if CHR2 is on the same chromosome, still ignore it\n        // because there should be another pairwise feature\n        // at the end of this one\n        const isTRA = info.indexOf('SVTYPE=TRA') !== -1;\n        if (info[0] !== '.' && !isTRA) {\n            let prevChar = ';';\n            for (let j = 0; j < info.length; j += 1) {\n                if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {\n                    let valueEnd = info.indexOf(';', j);\n                    if (valueEnd === -1) {\n                        valueEnd = info.length;\n                    }\n                    endCoordinate = parseInt(info.slice(j + 4, valueEnd), 10);\n                    break;\n                }\n                prevChar = info[j];\n            }\n        }\n        else if (isTRA) {\n            return startCoordinate + 1;\n        }\n        return endCoordinate;\n    }\n    /**\n     * return the approximate number of data lines in the given reference sequence\n     * @param {string} refSeq reference sequence name\n     * @returns {Promise} for number of data lines present on that reference sequence\n     */\n    async lineCount(refName, opts = {}) {\n        return this.index.lineCount(refName, opts);\n    }\n    async _readRegion(position, compressedSize, opts = {}) {\n        const { bytesRead, buffer } = await this.filehandle.read(Buffer.alloc(compressedSize), 0, compressedSize, position, opts);\n        return bytesRead < compressedSize ? buffer.slice(0, bytesRead) : buffer;\n    }\n    /**\n     * read and uncompress the data in a chunk (composed of one or more\n     * contiguous bgzip blocks) of the file\n     * @param {Chunk} chunk\n     * @returns {Promise} for a string chunk of the file\n     */\n    async readChunk(chunk, opts = {}) {\n        // fetch the uncompressed data, uncompress carefully a block at a time,\n        // and stop when done\n        const compressedData = await this._readRegion(chunk.minv.blockPosition, chunk.fetchedSize(), opts);\n        try {\n            return (0, bgzf_filehandle_1.unzipChunkSlice)(compressedData, chunk);\n        }\n        catch (e) {\n            throw new Error(`error decompressing chunk ${chunk.toString()} ${e}`);\n        }\n    }\n}\nexports.default = TabixIndexedFile;\n","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  FileLocation,\n  NoAssemblyRegion,\n  Region,\n} from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { bytesForRegions } from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport VcfParser from '@gmod/vcf'\nimport { Observer } from 'rxjs'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport VcfFeature from './VcfFeature'\nimport { GenericFilehandle } from 'generic-filehandle'\n\nexport default class extends BaseFeatureDataAdapter {\n  private configured?: Promise<{\n    filehandle: GenericFilehandle\n    vcf: TabixIndexedFile\n    parser: VcfParser\n  }>\n\n  private async configurePre() {\n    const vcfGzLocation = readConfObject(this.config, 'vcfGzLocation')\n    const location = readConfObject(this.config, ['index', 'location'])\n    const indexType = readConfObject(this.config, ['index', 'indexType'])\n\n    const filehandle = openLocation(\n      vcfGzLocation as FileLocation,\n      this.pluginManager,\n    )\n    const isCSI = indexType === 'CSI'\n    const vcf = new TabixIndexedFile({\n      filehandle,\n      csiFilehandle: isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      tbiFilehandle: !isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n      chunkSizeLimit: 1000000000,\n    })\n\n    const header = await vcf.getHeader()\n    return {\n      filehandle,\n      vcf,\n      parser: new VcfParser({ header }),\n    }\n  }\n\n  protected async configure() {\n    if (!this.configured) {\n      this.configured = this.configurePre().catch(e => {\n        this.configured = undefined\n        throw e\n      })\n    }\n    return this.configured\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { vcf } = await this.configure()\n    return vcf.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader() {\n    const { vcf } = await this.configure()\n    return vcf.getHeader()\n  }\n\n  async getMetadata() {\n    const { parser } = await this.configure()\n    return parser.getMetadata()\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { vcf, parser } = await this.configure()\n      await vcf.getLines(refName, start, end, {\n        lineCallback: (line: string, fileOffset: number) => {\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(line),\n              parser,\n              id: `${this.id}-vcf-${fileOffset}`,\n            }),\n          )\n        },\n        ...opts,\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  /**\n   * Checks if the data source has data for the given reference sequence,\n   * and then gets the features in the region if it does\n   *\n   * Currently this just calls getFeatureInRegion for each region. Adapters that\n   * are frequently called on multiple regions simultaneously may want to\n   * implement a more efficient custom version of this method.\n   *\n   * Also includes a bit of extra logging to warn when fetching a large portion\n   * of a VCF\n   * @param regions - Regions\n   * @param opts - Feature adapter options\n   * @returns Observable of Feature objects in the regions\n   */\n  public getFeaturesInMultipleRegions(\n    regions: Region[],\n    opts: BaseOptions = {},\n  ) {\n    // TODO: restore commented version below once TSDX supports Rollup v2\n    // xref: https://github.com/rollup/rollup/blob/master/CHANGELOG.md#bug-fixes-45\n    const superGetFeaturesInMultipleRegions = super.getFeaturesInMultipleRegions\n    return ObservableCreate<Feature>(async (observer: Observer<Feature>) => {\n      const { vcf } = await this.configure()\n\n      // @ts-ignore\n      const bytes = await bytesForRegions(regions, vcf.index)\n      const { filehandle } = await this.configure()\n      const stat = await filehandle.stat()\n      let pct = Math.round((bytes / stat.size) * 100)\n      if (pct > 100) {\n        // this is just a bad estimate, make 100% if it goes over\n        pct = 100\n      }\n      if (pct > 60) {\n        console.warn(\n          `getFeaturesInMultipleRegions fetching ${pct}% of VCF file, but whole-file streaming not yet implemented`,\n        )\n      }\n      superGetFeaturesInMultipleRegions\n        .call(this, regions, opts)\n        .subscribe(observer)\n      // super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer)\n    })\n  }\n\n  public freeResources(/* { region } */): void {}\n}\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n","module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","'use strict';\n\nclass QuickLRU {\n\tconstructor(options = {}) {\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst value = this.oldCache.get(key);\n\t\t\tthis.oldCache.delete(key);\n\t\t\tthis._set(key, value);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tset(key, value) {\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, value);\n\t\t} else {\n\t\t\tthis._set(key, value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\treturn this.cache.has(key) || this.oldCache.has(key);\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this.oldCache.get(key);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tyield item;\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget size() {\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn this._size + oldCacheSize;\n\t}\n}\n\nmodule.exports = QuickLRU;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.optimizeChunks = exports.canMergeBlocks = exports.abortBreakPoint = exports.checkAbortSignal = exports.longToNumber = void 0;\nfunction longToNumber(long) {\n    if (long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n        long.lessThan(Number.MIN_SAFE_INTEGER)) {\n        throw new Error('integer overflow');\n    }\n    return long.toNumber();\n}\nexports.longToNumber = longToNumber;\nclass AbortError extends Error {\n}\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nfunction checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        // console.log('bam aborted!')\n        if (typeof DOMException !== 'undefined') {\n            // eslint-disable-next-line  no-undef\n            throw new DOMException('aborted', 'AbortError');\n        }\n        else {\n            const e = new AbortError('aborted');\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n    }\n}\nexports.checkAbortSignal = checkAbortSignal;\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nasync function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexports.abortBreakPoint = abortBreakPoint;\nfunction canMergeBlocks(chunk1, chunk2) {\n    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);\n}\nexports.canMergeBlocks = canMergeBlocks;\nfunction optimizeChunks(chunks, lowest) {\n    const mergedChunks = [];\n    let lastChunk = null;\n    if (chunks.length === 0) {\n        return chunks;\n    }\n    chunks.sort(function (c0, c1) {\n        const dif = c0.minv.blockPosition - c1.minv.blockPosition;\n        if (dif !== 0) {\n            return dif;\n        }\n        else {\n            return c0.minv.dataPosition - c1.minv.dataPosition;\n        }\n    });\n    chunks.forEach(chunk => {\n        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n            if (lastChunk === null) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            }\n            else {\n                if (canMergeBlocks(lastChunk, chunk)) {\n                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                }\n                else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n        // else {\n        //   console.log(`skipping chunk ${chunk}`)\n        // }\n    });\n    return mergedChunks;\n}\nexports.optimizeChunks = optimizeChunks;\n","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst long_1 = __importDefault(require(\"long\"));\nconst virtualOffset_1 = __importStar(require(\"./virtualOffset\"));\nconst chunk_1 = __importDefault(require(\"./chunk\"));\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst util_1 = require(\"./util\");\nconst indexFile_1 = __importDefault(require(\"./indexFile\"));\nconst TBI_MAGIC = 21578324; // TBI\\1\nconst TAD_LIDX_SHIFT = 14;\n/**\n * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n */\nfunction reg2bins(beg, end) {\n    beg += 1; // < convert to 1-based closed\n    end -= 1;\n    return [\n        [0, 0],\n        [1 + (beg >> 26), 1 + (end >> 26)],\n        [9 + (beg >> 23), 9 + (end >> 23)],\n        [73 + (beg >> 20), 73 + (end >> 20)],\n        [585 + (beg >> 17), 585 + (end >> 17)],\n        [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ];\n}\nclass TabixIndex extends indexFile_1.default {\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return -1;\n        }\n        const refId = indexData.refNameToId[refName];\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        const { stats } = indexData.indices[refId];\n        if (stats) {\n            return stats.lineCount;\n        }\n        return -1;\n    }\n    // memoize\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const bytes = await (0, bgzf_filehandle_1.unzip)((await this.filehandle.readFile(opts)));\n        (0, util_1.checkAbortSignal)(opts.signal);\n        // check TBI magic numbers\n        if (bytes.readUInt32LE(0) !== TBI_MAGIC /* \"TBI\\1\" */) {\n            throw new Error('Not a TBI file');\n            // TODO: do we need to support big-endian TBI files?\n        }\n        // number of reference sequences in the index\n        const refCount = bytes.readInt32LE(4);\n        const formatFlags = bytes.readInt32LE(8);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const formatOpts = {\n            0: 'generic',\n            1: 'SAM',\n            2: 'VCF',\n        };\n        const format = formatOpts[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: bytes.readInt32LE(12),\n            start: bytes.readInt32LE(16),\n            end: bytes.readInt32LE(20),\n        };\n        const metaValue = bytes.readInt32LE(24);\n        const depth = 5;\n        const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (14 + depth * 3);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;\n        const skipLines = bytes.readInt32LE(28);\n        // read sequence dictionary\n        const nameSectionLength = bytes.readInt32LE(32);\n        const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));\n        // read the indexes for each reference sequence\n        let currOffset = 36 + nameSectionLength;\n        let firstDataLine;\n        const indices = new Array(refCount).fill(0).map(() => {\n            // the binning index\n            const binCount = bytes.readInt32LE(currOffset);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = bytes.readUInt32LE(currOffset);\n                currOffset += 4;\n                if (bin > maxBinNumber + 1) {\n                    throw new Error('tabix index contains too many bins, please use a CSI index');\n                }\n                else if (bin === maxBinNumber + 1) {\n                    const chunkCount = bytes.readInt32LE(currOffset);\n                    currOffset += 4;\n                    if (chunkCount === 2) {\n                        stats = this.parsePseudoBin(bytes, currOffset);\n                    }\n                    currOffset += 16 * chunkCount;\n                }\n                else {\n                    const chunkCount = bytes.readInt32LE(currOffset);\n                    currOffset += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = (0, virtualOffset_1.fromBytes)(bytes, currOffset);\n                        const v = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 8);\n                        currOffset += 16;\n                        firstDataLine = this._findFirstData(firstDataLine, u);\n                        chunks[k] = new chunk_1.default(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            // the linear index\n            const linearCount = bytes.readInt32LE(currOffset);\n            currOffset += 4;\n            const linearIndex = new Array(linearCount);\n            for (let k = 0; k < linearCount; k += 1) {\n                linearIndex[k] = (0, virtualOffset_1.fromBytes)(bytes, currOffset);\n                currOffset += 8;\n                firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);\n            }\n            return { binIndex, linearIndex, stats };\n        });\n        return {\n            indices,\n            metaChar,\n            maxBinNumber,\n            maxRefLength,\n            skipLines,\n            firstDataLine,\n            columnNumbers,\n            coordinateType,\n            format,\n            refIdToName,\n            refNameToId,\n            maxBlockSize: 1 << 16,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        const lineCount = (0, util_1.longToNumber)(long_1.default.fromBytesLE(bytes.slice(offset + 16, offset + 24), true));\n        return { lineCount };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    let refName = namesBytes.toString('utf8', currNameStart, i);\n                    refName = this.renameRefSeq(refName);\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return { refNameToId, refIdToName };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return [];\n        }\n        const refId = indexData.refNameToId[refName];\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        const minOffset = ba.linearIndex.length\n            ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length\n                ? ba.linearIndex.length - 1\n                : min >> TAD_LIDX_SHIFT]\n            : new virtualOffset_1.default(0, 0);\n        if (!minOffset) {\n            console.warn('querying outside of possible tabix range');\n        }\n        // const { linearIndex, binIndex } = indexes\n        const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (let c = 0; c < binChunks.length; ++c) {\n                        chunks.push(new chunk_1.default(binChunks[c].minv, binChunks[c].maxv, bin));\n                    }\n                }\n            }\n        }\n        // Use the linear index to find minimum file position of chunks that could\n        // contain alignments in the region\n        const nintv = ba.linearIndex.length;\n        let lowest = null;\n        const minLin = Math.min(min >> 14, nintv - 1);\n        const maxLin = Math.min(max >> 14, nintv - 1);\n        for (let i = minLin; i <= maxLin; ++i) {\n            const vp = ba.linearIndex[i];\n            if (vp) {\n                if (!lowest || vp.compareTo(lowest) < 0) {\n                    lowest = vp;\n                }\n            }\n        }\n        return (0, util_1.optimizeChunks)(chunks, lowest);\n    }\n}\nexports.default = TabixIndex;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromBytes = void 0;\nclass VirtualOffset {\n    constructor(blockPosition, dataPosition) {\n        this.blockPosition = blockPosition; // < offset of the compressed data block\n        this.dataPosition = dataPosition; // < offset into the uncompressed data\n    }\n    toString() {\n        return `${this.blockPosition}:${this.dataPosition}`;\n    }\n    compareTo(b) {\n        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);\n    }\n    static min(...args) {\n        let min;\n        let i = 0;\n        for (; !min; i += 1) {\n            min = args[i];\n        }\n        for (; i < args.length; i += 1) {\n            if (min.compareTo(args[i]) > 0) {\n                min = args[i];\n            }\n        }\n        return min;\n    }\n}\nexports.default = VirtualOffset;\nfunction fromBytes(bytes, offset = 0, bigendian = false) {\n    if (bigendian) {\n        throw new Error('big-endian virtual file offsets not implemented');\n    }\n    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +\n        bytes[offset + 6] * 0x100000000 +\n        bytes[offset + 5] * 0x1000000 +\n        bytes[offset + 4] * 0x10000 +\n        bytes[offset + 3] * 0x100 +\n        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);\n}\nexports.fromBytes = fromBytes;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// little class representing a chunk in the index\nclass Chunk {\n    /**\n     * @param {VirtualOffset} minv\n     * @param {VirtualOffset} maxv\n     * @param {number} bin\n     * @param {number} [fetchedSize]\n     */\n    constructor(minv, maxv, bin, fetchedSize = undefined) {\n        this.minv = minv;\n        this.maxv = maxv;\n        this.bin = bin;\n        this._fetchedSize = fetchedSize;\n    }\n    toUniqueString() {\n        return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;\n    }\n    toString() {\n        return this.toUniqueString();\n    }\n    compareTo(b) {\n        return (this.minv.compareTo(b.minv) ||\n            this.maxv.compareTo(b.maxv) ||\n            this.bin - b.bin);\n    }\n    fetchedSize() {\n        if (this._fetchedSize !== undefined) {\n            return this._fetchedSize;\n        }\n        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;\n    }\n}\nexports.default = Chunk;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortable_promise_cache_1 = __importDefault(require(\"abortable-promise-cache\"));\nconst quick_lru_1 = __importDefault(require(\"quick-lru\"));\nclass IndexFile {\n    /**\n     * @param {filehandle} filehandle\n     * @param {function} [renameRefSeqs]\n     */\n    constructor({ filehandle, renameRefSeqs = (n) => n, }) {\n        this.filehandle = filehandle;\n        this.renameRefSeq = renameRefSeqs;\n    }\n    async getMetadata(opts = {}) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { indices, ...rest } = await this.parse(opts);\n        return rest;\n    }\n    _findFirstData(currentFdl, virtualOffset) {\n        if (currentFdl) {\n            return currentFdl.compareTo(virtualOffset) > 0\n                ? virtualOffset\n                : currentFdl;\n        }\n        else {\n            return virtualOffset;\n        }\n    }\n    async parse(opts = {}) {\n        if (!this._parseCache) {\n            this._parseCache = new abortable_promise_cache_1.default({\n                cache: new quick_lru_1.default({ maxSize: 1 }),\n                fill: () => this._parse(opts),\n            });\n        }\n        return this._parseCache.get('index', null, undefined);\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        return !!((await this.parse(opts)).indices[seqId] || {}).binIndex;\n    }\n}\nexports.default = IndexFile;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst long_1 = __importDefault(require(\"long\"));\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst virtualOffset_1 = __importStar(require(\"./virtualOffset\"));\nconst chunk_1 = __importDefault(require(\"./chunk\"));\nconst util_1 = require(\"./util\");\nconst indexFile_1 = __importDefault(require(\"./indexFile\"));\nconst CSI1_MAGIC = 21582659; // CSI\\1\nconst CSI2_MAGIC = 38359875; // CSI\\2\nfunction lshift(num, bits) {\n    return num * 2 ** bits;\n}\nfunction rshift(num, bits) {\n    return Math.floor(num / 2 ** bits);\n}\nclass CSI extends indexFile_1.default {\n    constructor(args) {\n        super(args);\n        this.maxBinNumber = 0;\n        this.depth = 0;\n        this.minShift = 0;\n    }\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return -1;\n        }\n        const refId = indexData.refNameToId[refName];\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        const { stats } = indexData.indices[refId];\n        if (stats) {\n            return stats.lineCount;\n        }\n        return -1;\n    }\n    async indexCov() {\n        throw new Error('CSI indexes do not support indexcov');\n        return [];\n    }\n    parseAuxData(bytes, offset, auxLength) {\n        if (auxLength < 30) {\n            return {\n                refIdToName: [],\n                refNameToId: {},\n            };\n        }\n        const formatFlags = bytes.readInt32LE(offset);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: bytes.readInt32LE(offset + 4),\n            start: bytes.readInt32LE(offset + 8),\n            end: bytes.readInt32LE(offset + 12),\n        };\n        const metaValue = bytes.readInt32LE(offset + 16);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : '';\n        const skipLines = bytes.readInt32LE(offset + 20);\n        const nameSectionLength = bytes.readInt32LE(offset + 24);\n        const { refIdToName, refNameToId } = this._parseNameBytes(bytes.slice(offset + 28, offset + 28 + nameSectionLength));\n        return {\n            refIdToName,\n            refNameToId,\n            skipLines,\n            metaChar,\n            columnNumbers,\n            format,\n            coordinateType,\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    let refName = namesBytes.toString('utf8', currNameStart, i);\n                    refName = this.renameRefSeq(refName);\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return { refNameToId, refIdToName };\n    }\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const bytes = await (0, bgzf_filehandle_1.unzip)((await this.filehandle.readFile(opts)));\n        // check TBI magic numbers\n        let csiVersion;\n        if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n            csiVersion = 1;\n        }\n        else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n            csiVersion = 2;\n        }\n        else {\n            throw new Error('Not a CSI file');\n            // TODO: do we need to support big-endian CSI files?\n        }\n        this.minShift = bytes.readInt32LE(4);\n        this.depth = bytes.readInt32LE(8);\n        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (this.minShift + this.depth * 3);\n        const auxLength = bytes.readInt32LE(12);\n        let aux = {\n            refIdToName: [],\n            refNameToId: {},\n        };\n        if (auxLength) {\n            aux = this.parseAuxData(bytes, 16, auxLength);\n        }\n        const refCount = bytes.readInt32LE(16 + auxLength);\n        // read the indexes for each reference sequence\n        let firstDataLine;\n        let currOffset = 16 + auxLength + 4;\n        const indices = new Array(refCount).fill(0).map(() => {\n            // the binning index\n            const binCount = bytes.readInt32LE(currOffset);\n            currOffset += 4;\n            const binIndex = {};\n            let stats; // < provided by parsing a pseudo-bin, if present\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = bytes.readUInt32LE(currOffset);\n                if (bin > this.maxBinNumber) {\n                    // this is a fake bin that actually has stats information\n                    // about the reference sequence in it\n                    stats = this.parsePseudoBin(bytes, currOffset + 4);\n                    currOffset += 4 + 8 + 4 + 16 + 16;\n                }\n                else {\n                    const loffset = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 4);\n                    firstDataLine = this._findFirstData(firstDataLine, loffset);\n                    const chunkCount = bytes.readInt32LE(currOffset + 12);\n                    currOffset += 16;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = (0, virtualOffset_1.fromBytes)(bytes, currOffset);\n                        const v = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 8);\n                        currOffset += 16;\n                        // this._findFirstData(data, u)\n                        chunks[k] = new chunk_1.default(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            return { binIndex, stats };\n        });\n        return {\n            ...aux,\n            csi: true,\n            refCount,\n            maxBlockSize: 1 << 16,\n            firstDataLine,\n            csiVersion,\n            indices,\n            depth: this.depth,\n            maxBinNumber: this.maxBinNumber,\n            maxRefLength,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        const lineCount = (0, util_1.longToNumber)(long_1.default.fromBytesLE(Array.prototype.slice.call(bytes, offset + 28, offset + 36), true));\n        return { lineCount };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return [];\n        }\n        const refId = indexData.refNameToId[refName];\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        // const { linearIndex, binIndex } = indexes\n        const overlappingBins = this.reg2bins(min, max); // List of bin #s that overlap min, max\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (let c = 0; c < binChunks.length; ++c) {\n                        chunks.push(new chunk_1.default(binChunks[c].minv, binChunks[c].maxv, bin));\n                    }\n                }\n            }\n        }\n        return (0, util_1.optimizeChunks)(chunks, new virtualOffset_1.default(0, 0));\n    }\n    /**\n     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n     */\n    reg2bins(beg, end) {\n        beg -= 1; // < convert to 1-based closed\n        if (beg < 1) {\n            beg = 1;\n        }\n        if (end > 2 ** 50) {\n            end = 2 ** 34;\n        } // 17 GiB ought to be enough for anybody\n        end -= 1;\n        let l = 0;\n        let t = 0;\n        let s = this.minShift + this.depth * 3;\n        const bins = [];\n        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n            const b = t + rshift(beg, s);\n            const e = t + rshift(end, s);\n            if (e - b + bins.length > this.maxBinNumber) {\n                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);\n            }\n            bins.push([b, e]);\n        }\n        return bins;\n    }\n}\nexports.default = CSI;\n"],"sourceRoot":""}